<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- /fasttmp/mkdist-qt-4.4.0-1209388211/qt-win-opensource-src-4.4.0/src/corelib/kernel/qobject.cpp -->
<head>
  <title>Qt 4.4: QObject Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><a href="http://www.trolltech.com"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></a></td></tr></table><h1 class="title">QObject Class Reference<br /><span class="small-subtitle">[<a href="qtcore.html">QtCore</a> module]</span>
</h1>
<p>The QObject class is the base class of all Qt objects. <a href="#details">More...</a></p>
<pre> #include &lt;QObject&gt;</pre><p>Inherited by <a href="phonon-backendcapabilities-notifier.html">Phonon::BackendCapabilities::Notifier</a>, <a href="phonon-effect.html">Phonon::Effect</a>, <a href="phonon-factory-sender.html">Phonon::Factory::Sender</a>, <a href="phonon-globalconfig.html">Phonon::GlobalConfig</a>, <a href="phonon-mediaobject.html">Phonon::MediaObject</a>, <a href="q3accel.html" class="compat">Q3Accel</a>, <a href="q3action.html" class="compat">Q3Action</a>, <a href="q3canvas.html" class="compat">Q3Canvas</a>, <a href="q3dns.html" class="compat">Q3Dns</a>, <a href="q3dragobject.html" class="compat">Q3DragObject</a>, <a href="q3editorfactory.html" class="compat">Q3EditorFactory</a>, <a href="q3fileiconprovider.html" class="compat">Q3FileIconProvider</a>, <a href="q3networkoperation.html" class="compat">Q3NetworkOperation</a>, <a href="q3networkprotocol.html" class="compat">Q3NetworkProtocol</a>, <a href="q3process.html" class="compat">Q3Process</a>, <a href="q3serversocket.html" class="compat">Q3ServerSocket</a>, <a href="q3signal.html" class="compat">Q3Signal</a>, <a href="q3sqlform.html" class="compat">Q3SqlForm</a>, <a href="q3stylesheet.html" class="compat">Q3StyleSheet</a>, <a href="q3urloperator.html" class="compat">Q3UrlOperator</a>, <a href="q3whatsthis.html" class="compat">Q3WhatsThis</a>, <a href="qabstracteventdispatcher.html">QAbstractEventDispatcher</a>, <a href="qabstractitemdelegate.html">QAbstractItemDelegate</a>, <a href="qabstractitemmodel.html">QAbstractItemModel</a>, <a href="qabstractmessagehandler.html">QAbstractMessageHandler</a>, <a href="qabstracttextdocumentlayout.html">QAbstractTextDocumentLayout</a>, <a href="qabstracturiresolver.html">QAbstractUriResolver</a>, <a href="qaccessiblebridgeplugin.html">QAccessibleBridgePlugin</a>, <a href="qaccessibleplugin.html">QAccessiblePlugin</a>, <a href="qaction.html">QAction</a>, <a href="qactiongroup.html">QActionGroup</a>, <a href="qassistantclient.html" class="obsolete">QAssistantClient</a>, <a href="qbuttongroup.html">QButtonGroup</a>, <a href="qclipboard.html">QClipboard</a>, <a href="qcompleter.html">QCompleter</a>, <a href="qcoreapplication.html">QCoreApplication</a>, <a href="qdatawidgetmapper.html">QDataWidgetMapper</a>, <a href="qdbusabstractadaptor.html">QDBusAbstractAdaptor</a>, <a href="qdbusabstractinterface.html">QDBusAbstractInterface</a>, <a href="qdbusserver.html">QDBusServer</a>, <a href="qdesignerformeditorinterface.html">QDesignerFormEditorInterface</a>, <a href="qdesignerformwindowmanagerinterface.html">QDesignerFormWindowManagerInterface</a>, <a href="qdrag.html">QDrag</a>, <a href="qeventloop.html">QEventLoop</a>, <a href="qextensionfactory.html">QExtensionFactory</a>, <a href="qextensionmanager.html">QExtensionManager</a>, <a href="qfilesystemwatcher.html">QFileSystemWatcher</a>, <a href="qftp.html">QFtp</a>, <a href="qfuturewatcher.html">QFutureWatcher</a>, <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>, <a href="qgraphicsscene.html">QGraphicsScene</a>, <a href="qgraphicssvgitem.html">QGraphicsSvgItem</a>, <a href="qgraphicstextitem.html">QGraphicsTextItem</a>, <a href="qgraphicswidget.html">QGraphicsWidget</a>, <a href="qhelpenginecore.html">QHelpEngineCore</a>, <a href="qhelpsearchengine.html">QHelpSearchEngine</a>, <a href="qhttp.html">QHttp</a>, <a href="qiconengineplugin.html">QIconEnginePlugin</a>, <a href="qiconenginepluginv2.html">QIconEnginePluginV2</a>, <a href="qimageioplugin.html">QImageIOPlugin</a>, <a href="qinputcontext.html">QInputContext</a>, <a href="qinputcontextplugin.html">QInputContextPlugin</a>, <a href="qiodevice.html">QIODevice</a>, <a href="qitemselectionmodel.html">QItemSelectionModel</a>, <a href="qlayout.html">QLayout</a>, <a href="qlibrary.html">QLibrary</a>, <a href="qlocalserver.html">QLocalServer</a>, <a href="qmdi-controlcontainer.html">QMdi::ControlContainer</a>, <a href="qmimedata.html">QMimeData</a>, <a href="qmovie.html">QMovie</a>, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, <a href="qnetworkcookiejar.html">QNetworkCookieJar</a>, <a href="qobjectcleanuphandler.html">QObjectCleanupHandler</a>, <a href="qpictureformatplugin.html" class="obsolete">QPictureFormatPlugin</a>, <a href="qpluginloader.html">QPluginLoader</a>, <a href="qscriptengine.html">QScriptEngine</a>, <a href="qscriptextensionplugin.html">QScriptExtensionPlugin</a>, <a href="qsessionmanager.html">QSessionManager</a>, <a href="qsettings.html">QSettings</a>, <a href="qsharedmemory.html">QSharedMemory</a>, <a href="qshortcut.html">QShortcut</a>, <a href="qsignalmapper.html">QSignalMapper</a>, <a href="qsignalspy.html">QSignalSpy</a>, <a href="qsocketnotifier.html">QSocketNotifier</a>, <a href="qsound.html">QSound</a>, <a href="qsqldriver.html">QSqlDriver</a>, <a href="qsqldriverplugin.html">QSqlDriverPlugin</a>, <a href="qstyle.html">QStyle</a>, <a href="qstyleplugin.html">QStylePlugin</a>, <a href="qsvgrenderer.html">QSvgRenderer</a>, <a href="qsyntaxhighlighter.html">QSyntaxHighlighter</a>, <a href="qsystemtrayicon.html">QSystemTrayIcon</a>, <a href="qtcpserver.html">QTcpServer</a>, <a href="qtextcodecplugin.html">QTextCodecPlugin</a>, <a href="qtextdocument.html">QTextDocument</a>, <a href="qtextobject.html">QTextObject</a>, <a href="qthread.html">QThread</a>, <a href="qthreadpool.html">QThreadPool</a>, <a href="qtimeline.html">QTimeLine</a>, <a href="qtimer.html">QTimer</a>, <a href="qtranslator.html">QTranslator</a>, <a href="quiloader.html">QUiLoader</a>, <a href="qundogroup.html">QUndoGroup</a>, <a href="qundostack.html">QUndoStack</a>, <a href="qvalidator.html">QValidator</a>, <a href="qwebframe.html">QWebFrame</a>, <a href="qwebhistoryinterface.html">QWebHistoryInterface</a>, <a href="qwebpage.html">QWebPage</a>, <a href="qwebpluginfactory.html">QWebPluginFactory</a>, <a href="qwidget.html">QWidget</a>, <a href="webcore-frameloaderclientqt.html">WebCore::FrameLoaderClientQt</a>, </p>
<p><b>Note:</b> All the functions in this class are <a href="threads.html#reentrant">reentrant</a>, except <a href="qobject.html#connect">connect</a>(), <a href="qobject.html#connect-2">connect</a>(), <a href="qobject.html#disconnect">disconnect</a>(), and <a href="qobject.html#disconnect-2">disconnect</a>().</p>
<ul>
<li><a href="qobject-members.html">List of all members, including inherited members</a></li>
<li><a href="qobject-qt3.html">Qt 3 support members</a></li>
</ul>
<a name="properties"></a>
<h3>Properties</h3>
<ul>
<li><div class="fn"/><b><a href="qobject.html#objectName-prop">objectName</a></b> : QString</li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qobject.html#QObject">QObject</a></b> ( QObject * <i>parent</i> = 0 )</li>
<li><div class="fn"/>virtual <b><a href="qobject.html#dtor.QObject">~QObject</a></b> ()</li>
<li><div class="fn"/>bool <b><a href="qobject.html#blockSignals">blockSignals</a></b> ( bool <i>block</i> )</li>
<li><div class="fn"/>const QObjectList &amp; <b><a href="qobject.html#children">children</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qobject.html#connect-2">connect</a></b> ( const QObject * <i>sender</i>, const char * <i>signal</i>, const char * <i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoCompatConnection ) const</li>
<li><div class="fn"/>bool <b><a href="qobject.html#disconnect-2">disconnect</a></b> ( const char * <i>signal</i> = 0, const QObject * <i>receiver</i> = 0, const char * <i>method</i> = 0 )</li>
<li><div class="fn"/>bool <b><a href="qobject.html#disconnect-3">disconnect</a></b> ( const QObject * <i>receiver</i>, const char * <i>method</i> = 0 )</li>
<li><div class="fn"/>void <b><a href="qobject.html#dumpObjectInfo">dumpObjectInfo</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qobject.html#dumpObjectTree">dumpObjectTree</a></b> ()</li>
<li><div class="fn"/>QList&lt;QByteArray&gt; <b><a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qobject.html#event">event</a></b> ( QEvent * <i>e</i> )</li>
<li><div class="fn"/>virtual bool <b><a href="qobject.html#eventFilter">eventFilter</a></b> ( QObject * <i>watched</i>, QEvent * <i>event</i> )</li>
<li><div class="fn"/>T <b><a href="qobject.html#findChild">findChild</a></b> ( const QString &amp; <i>name</i> = QString() ) const</li>
<li><div class="fn"/>QList&lt;T&gt; <b><a href="qobject.html#findChildren">findChildren</a></b> ( const QString &amp; <i>name</i> = QString() ) const</li>
<li><div class="fn"/>QList&lt;T&gt; <b><a href="qobject.html#findChildren-2">findChildren</a></b> ( const QRegExp &amp; <i>regExp</i> ) const</li>
<li><div class="fn"/>bool <b><a href="qobject.html#inherits">inherits</a></b> ( const char * <i>className</i> ) const</li>
<li><div class="fn"/>void <b><a href="qobject.html#installEventFilter">installEventFilter</a></b> ( QObject * <i>filterObj</i> )</li>
<li><div class="fn"/>bool <b><a href="qobject.html#isWidgetType">isWidgetType</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qobject.html#killTimer">killTimer</a></b> ( int <i>id</i> )</li>
<li><div class="fn"/>virtual const QMetaObject * <b><a href="qobject.html#metaObject">metaObject</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qobject.html#moveToThread">moveToThread</a></b> ( QThread * <i>targetThread</i> )</li>
<li><div class="fn"/>QString <b><a href="qobject.html#objectName-prop">objectName</a></b> () const</li>
<li><div class="fn"/>QObject * <b><a href="qobject.html#parent">parent</a></b> () const</li>
<li><div class="fn"/>QVariant <b><a href="qobject.html#property">property</a></b> ( const char * <i>name</i> ) const</li>
<li><div class="fn"/>void <b><a href="qobject.html#removeEventFilter">removeEventFilter</a></b> ( QObject * <i>obj</i> )</li>
<li><div class="fn"/>void <b><a href="qobject.html#objectName-prop">setObjectName</a></b> ( const QString &amp; <i>name</i> )</li>
<li><div class="fn"/>void <b><a href="qobject.html#setParent">setParent</a></b> ( QObject * <i>parent</i> )</li>
<li><div class="fn"/>bool <b><a href="qobject.html#setProperty">setProperty</a></b> ( const char * <i>name</i>, const QVariant &amp; <i>value</i> )</li>
<li><div class="fn"/>bool <b><a href="qobject.html#signalsBlocked">signalsBlocked</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qobject.html#startTimer">startTimer</a></b> ( int <i>interval</i> )</li>
<li><div class="fn"/>QThread * <b><a href="qobject.html#thread">thread</a></b> () const</li>
</ul>
<a name="public-slots"></a>
<h3>Public Slots</h3>
<ul>
<li><div class="fn"/>void <b><a href="qobject.html#deleteLater">deleteLater</a></b> ()</li>
</ul>
<a name="signals"></a>
<h3>Signals</h3>
<ul>
<li><div class="fn"/>void <b><a href="qobject.html#destroyed">destroyed</a></b> ( QObject * <i>obj</i> = 0 )</li>
</ul>
<a name="static-public-members"></a>
<h3>Static Public Members</h3>
<ul>
<li><div class="fn"/>bool <b><a href="qobject.html#connect">connect</a></b> ( const QObject * <i>sender</i>, const char * <i>signal</i>, const QObject * <i>receiver</i>, const char * <i>method</i>, Qt::ConnectionType <i>type</i> = Qt::AutoCompatConnection )</li>
<li><div class="fn"/>bool <b><a href="qobject.html#disconnect">disconnect</a></b> ( const QObject * <i>sender</i>, const char * <i>signal</i>, const QObject * <i>receiver</i>, const char * <i>method</i> )</li>
<li><div class="fn"/>const QMetaObject <b><a href="qobject.html#staticMetaObject-var">staticMetaObject</a></b></li>
<li><div class="fn"/>QString <b><a href="qobject.html#tr">tr</a></b> ( const char * <i>sourceText</i>, const char * <i>comment</i> = 0, int <i>n</i> = -1 )</li>
<li><div class="fn"/>QString <b><a href="qobject.html#trUtf8">trUtf8</a></b> ( const char * <i>sourceText</i>, const char * <i>comment</i> = 0, int <i>n</i> = -1 )</li>
</ul>
<a name="protected-functions"></a>
<h3>Protected Functions</h3>
<ul>
<li><div class="fn"/>virtual void <b><a href="qobject.html#childEvent">childEvent</a></b> ( QChildEvent * <i>event</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qobject.html#connectNotify">connectNotify</a></b> ( const char * <i>signal</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qobject.html#customEvent">customEvent</a></b> ( QEvent * <i>event</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qobject.html#disconnectNotify">disconnectNotify</a></b> ( const char * <i>signal</i> )</li>
<li><div class="fn"/>int <b><a href="qobject.html#receivers">receivers</a></b> ( const char * <i>signal</i> ) const</li>
<li><div class="fn"/>QObject * <b><a href="qobject.html#sender">sender</a></b> () const</li>
<li><div class="fn"/>virtual void <b><a href="qobject.html#timerEvent">timerEvent</a></b> ( QTimerEvent * <i>event</i> )</li>
</ul>
<a name="related-non-members"></a>
<h3>Related Non-Members</h3>
<ul>
<li><div class="fn"/>typedef <b><a href="qobject.html#QObjectList-typedef">QObjectList</a></b></li>
<li><div class="fn"/>T <b><a href="qobject.html#qFindChild">qFindChild</a></b> ( const QObject * <i>obj</i>, const QString &amp; <i>name</i> )</li>
<li><div class="fn"/>QList&lt;T&gt; <b><a href="qobject.html#qFindChildren">qFindChildren</a></b> ( const QObject * <i>obj</i>, const QString &amp; <i>name</i> )</li>
<li><div class="fn"/>QList&lt;T&gt; <b><a href="qobject.html#qFindChildren-6">qFindChildren</a></b> ( const QObject * <i>obj</i>, const QRegExp &amp; <i>regExp</i> )</li>
<li><div class="fn"/>T <b><a href="qobject.html#qobject_cast">qobject_cast</a></b> ( QObject * <i>object</i> )</li>
</ul>
<a name="macros"></a>
<h3>Macros</h3>
<ul>
<li><div class="fn"/><b><a href="qobject.html#Q_CLASSINFO">Q_CLASSINFO</a></b> (  <i>Name</i>,  <i>Value</i> )</li>
<li><div class="fn"/><b><a href="qobject.html#Q_ENUMS">Q_ENUMS</a></b> ( ... )</li>
<li><div class="fn"/><b><a href="qobject.html#Q_FLAGS">Q_FLAGS</a></b> ( ... )</li>
<li><div class="fn"/><b><a href="qobject.html#Q_INTERFACES">Q_INTERFACES</a></b> ( ... )</li>
<li><div class="fn"/><b><a href="qobject.html#Q_OBJECT">Q_OBJECT</a></b></li>
<li><div class="fn"/><b><a href="qobject.html#Q_PROPERTY">Q_PROPERTY</a></b> ( ... )</li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QObject class is the base class of all Qt objects.</p>
<p>QObject is the heart of the <a href="object.html">Qt object model</a>. The central feature in this model is a very powerful mechanism for seamless object communication called <a href="signalsandslots.html">signals and slots</a>. You can connect a signal to a slot with <a href="qobject.html#connect">connect</a>() and destroy the connection with <a href="qobject.html#disconnect">disconnect</a>(). To avoid never ending notification loops you can temporarily block signals with <a href="qobject.html#blockSignals">blockSignals</a>(). The protected functions <a href="qobject.html#connectNotify">connectNotify</a>() and <a href="qobject.html#disconnectNotify">disconnectNotify</a>() make it possible to track connections.</p>
<p>QObjects organize themselves in object trees. When you create a QObject with another object as parent, the object will automatically add itself to the parent's <a href="qobject.html#children">children</a>() list. The parent takes ownership of the object i.e&#x2e; it will automatically delete its children in its destructor. You can look for an object by name and optionally type using <a href="qobject.html#findChild">findChild</a>() or <a href="qobject.html#findChildren">findChildren</a>().</p>
<p>Every object has an <a href="qobject.html#objectName-prop">objectName</a>() and its class name can be found via the corresponding <a href="qobject.html#metaObject">metaObject</a>() (see <a href="qmetaobject.html#className">QMetaObject::className</a>()). You can determine whether the object's class inherits another class in the QObject inheritance hierarchy by using the <a href="qobject.html#inherits">inherits</a>() function.</p>
<p>When an object is deleted, it emits a <a href="qobject.html#destroyed">destroyed</a>() signal. You can catch this signal to avoid dangling references to QObjects.</p>
<p>QObjects can receive events through <a href="qobject.html#event">event</a>() and filter the events of other objects. See <a href="qobject.html#installEventFilter">installEventFilter</a>() and <a href="qobject.html#eventFilter">eventFilter</a>() for details. A convenience handler, <a href="qobject.html#childEvent">childEvent</a>(), can be reimplemented to catch child events.</p>
<p>Events are delivered in the thread in which the object was created; see <a href="threads.html">Thread Support in Qt</a> and <a href="qobject.html#thread">thread</a>() for details. Note that event processing is not done at all for QObjects with no thread affinity (<a href="qobject.html#thread">thread</a>() returns zero). Use the <a href="qobject.html#moveToThread">moveToThread</a>() function to change the thread affinity for an object and its children (the object cannot be moved if it has a parent).</p>
<p>Last but not least, QObject provides the basic timer support in Qt; see <a href="qtimer.html">QTimer</a> for high-level support for timers.</p>
<p>Notice that the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro is mandatory for any object that implements signals, slots or properties. You also need to run the <a href="moc.html#moc">Meta Object Compiler</a> on the source file. We strongly recommend the use of this macro in all subclasses of QObject regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</p>
<p>All Qt widgets inherit QObject. The convenience function <a href="qobject.html#isWidgetType">isWidgetType</a>() returns whether an object is actually a widget. It is much faster than <a href="qobject.html#qobject_cast">qobject_cast</a>&lt;<a href="qwidget.html">QWidget</a> *&gt;(<i>obj</i>) or <i>obj</i>-&gt;<a href="qobject.html#inherits">inherits</a>(&quot;<a href="qwidget.html">QWidget</a>&quot;).</p>
<p>Some QObject functions, e.g&#x2e; <a href="qobject.html#children">children</a>(), return a <a href="qobject.html#QObjectList-typedef">QObjectList</a>. <a href="qobject.html#QObjectList-typedef">QObjectList</a> is a typedef for <a href="qlist.html">QList</a>&lt;QObject *&gt;.</p>
<a name="auto-connection"></a>
<h3>Auto-Connection</h3>
<p>Qt's meta-object system provides a mechanism to automatically connect signals and slots between QObject subclasses and their children. As long as objects are defined with suitable object names, and slots follow a simple naming convention, this connection can be performed at run-time by the <a href="qmetaobject.html#connectSlotsByName">QMetaObject::connectSlotsByName</a>() function.</p>
<p><a href="uic.html#uic">uic</a> generates code that invokes this function to enable auto-connection to be performed between widgets on forms created with <i>Qt Designer</i>. More information about using auto-connection with <i>Qt Designer</i> is given in the <a href="designer-using-a-component.html">Using a Component in Your Application</a> section of the <i>Qt Designer</i> manual.</p>
<a name="dynamic-properties"></a>
<h3>Dynamic Properties</h3>
<p>From Qt 4.2, dynamic properties can be added to and removed from QObject instances at run-time. Dynamic properties do not need to be declared at compile-time, yet they provide the same advantages as static properties and are manipulated using the same API - using <a href="qobject.html#property">property</a>() to read them and <a href="qobject.html#setProperty">setProperty</a>() to write them.</p>
<p>From Qt 4.3, dynamic properties are supported by <a href="designer-editing-mode.html#the-property-editor">Qt Designer</a>, and both standard Qt widgets and user-created forms can be given dynamic properties.</p>
<p>See also <a href="qmetaobject.html">QMetaObject</a>, <a href="qpointer.html">QPointer</a>, <a href="qobjectcleanuphandler.html">QObjectCleanupHandler</a>, and <a href="objecttrees.html">Object Trees and Object Ownership</a>.</p>
<hr />
<h2>Property Documentation</h2>
<h3 class="fn"><a name="objectName-prop"></a>objectName : <a href="qstring.html">QString</a></h3>
<p>This property holds the name of this object.</p>
<p>You can find an object by name (and type) using <a href="qobject.html#findChild">findChild</a>(). You can find a set of objects with <a href="qobject.html#findChildren">findChildren</a>().</p>
<pre>         qDebug(&quot;MyClass::setPrecision(): (%s) invalid precision %f&quot;,
                qPrintable(objectName()), newPrecision);</pre>
<p>Access functions:</p>
<ul>
<li><div class="fn"/><b>QString objectName () const</b></li>
<li><div class="fn"/><b>void setObjectName ( const QString &amp; <i>name</i> )</b></li>
</ul>
<p>See also <a href="qobject.html#metaObject">metaObject</a>() and <a href="qmetaobject.html#className">QMetaObject::className</a>().</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="QObject"></a>QObject::QObject ( QObject * <i>parent</i> = 0 )</h3>
<p>Constructs an object with parent object <i>parent</i>.</p>
<p>The parent of an object may be viewed as the object's owner. For instance, a <a href="qdialog.html">dialog box</a> is the parent of the <b>OK</b> and <b>Cancel</b> buttons it contains.</p>
<p>The destructor of a parent object destroys all child objects.</p>
<p>Setting <i>parent</i> to 0 constructs an object with no parent. If the object is a widget, it will become a top-level window.</p>
<p>See also <a href="qobject.html#parent">parent</a>(), <a href="qobject.html#findChild">findChild</a>(), and <a href="qobject.html#findChildren">findChildren</a>().</p>
<h3 class="fn"><a name="dtor.QObject"></a>QObject::~QObject ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Destroys the object, deleting all its child objects.</p>
<p>All signals to and from the object are automatically disconnected, and any pending posted events for the object are removed from the event queue. However, it is often safer to use <a href="qobject.html#deleteLater">deleteLater</a>() rather than deleting a <a href="qobject.html">QObject</a> subclass directly.</p>
<p><b>Warning:</b> All child objects are deleted. If any of these objects are on the stack or global, sooner or later your program will crash. We do not recommend holding pointers to child objects from outside the parent. If you still do, the <a href="qobject.html#destroyed">destroyed</a>() signal gives you an opportunity to detect when an object is destroyed.</p>
<p><b>Warning:</b> Deleting a <a href="qobject.html">QObject</a> while pending events are waiting to be delivered can cause a crash. You must not delete the <a href="qobject.html">QObject</a> directly if it exists in a different thread than the one currently executing. Use <a href="qobject.html#deleteLater">deleteLater</a>() instead, which will cause the event loop to delete the object after all pending events have been delivered to it.</p>
<p>See also <a href="qobject.html#deleteLater">deleteLater</a>().</p>
<h3 class="fn"><a name="blockSignals"></a>bool QObject::blockSignals ( bool <i>block</i> )</h3>
<p>If <i>block</i> is true, signals emitted by this object are blocked (i.e&#x2e;, emitting a signal will not invoke anything connected to it). If <i>block</i> is false, no such blocking will occur.</p>
<p>The return value is the previous value of <a href="qobject.html#signalsBlocked">signalsBlocked</a>().</p>
<p>Note that the <a href="qobject.html#destroyed">destroyed</a>() signal will be emitted even if the signals for this object have been blocked.</p>
<p>See also <a href="qobject.html#signalsBlocked">signalsBlocked</a>().</p>
<h3 class="fn"><a name="childEvent"></a>void QObject::childEvent ( <a href="qchildevent.html">QChildEvent</a> * <i>event</i> )&nbsp;&nbsp;<tt> [virtual protected]</tt></h3>
<p>This event handler can be reimplemented in a subclass to receive child events. The event is passed in the <i>event</i> parameter.</p>
<p><a href="qevent.html#Type-enum">QEvent::ChildAdded</a> and <a href="qevent.html#Type-enum">QEvent::ChildRemoved</a> events are sent to objects when children are added or removed. In both cases you can only rely on the child being a <a href="qobject.html">QObject</a>, or if <a href="qobject.html#isWidgetType">isWidgetType</a>() returns true, a <a href="qwidget.html">QWidget</a>. (This is because, in the <a href="qevent.html#Type-enum">ChildAdded</a> case, the child is not yet fully constructed, and in the <a href="qevent.html#Type-enum">ChildRemoved</a> case it might have been destructed already).</p>
<p><a href="qevent.html#Type-enum">QEvent::ChildPolished</a> events are sent to widgets when children are polished, or when polished children are added. If you receive a child polished event, the child's construction is usually completed.</p>
<p>For every child widget, you receive one <a href="qevent.html#Type-enum">ChildAdded</a> event, zero or more <a href="qevent.html#Type-enum">ChildPolished</a> events, and one <a href="qevent.html#Type-enum">ChildRemoved</a> event.</p>
<p>The <a href="qevent.html#Type-enum">ChildPolished</a> event is omitted if a child is removed immediately after it is added. If a child is polished several times during construction and destruction, you may receive several child polished events for the same child, each time with a different virtual table.</p>
<p>See also <a href="qobject.html#event">event</a>().</p>
<h3 class="fn"><a name="children"></a>const <a href="qobject.html#QObjectList-typedef">QObjectList</a> &amp; QObject::children () const</h3>
<p>Returns a list of child objects. The <a href="qobject.html#QObjectList-typedef">QObjectList</a> class is defined in the <tt>&lt;QObject&gt;</tt> header file as the following:</p>
<pre> typedef QList&lt;QObject*&gt; QObjectList;</pre>
<p>The first child added is the <a href="qlist.html#first">first</a> object in the list and the last child added is the <a href="qlist.html#last">last</a> object in the list, i.e&#x2e; new children are appended at the end.</p>
<p>Note that the list order changes when <a href="qwidget.html">QWidget</a> children are <a href="qwidget.html#raise">raised</a> or <a href="qwidget.html#lower">lowered</a>. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.</p>
<p>See also <a href="qobject.html#findChild">findChild</a>(), <a href="qobject.html#findChildren">findChildren</a>(), <a href="qobject.html#parent">parent</a>(), and <a href="qobject.html#setParent">setParent</a>().</p>
<h3 class="fn"><a name="connect"></a>bool QObject::connect ( const QObject * <i>sender</i>, const char * <i>signal</i>, const QObject * <i>receiver</i>, const char * <i>method</i>, <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a> <i>type</i> = Qt::AutoCompatConnection )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Creates a connection of the given <i>type</i> from the <i>signal</i> in the <i>sender</i> object to the <i>method</i> in the <i>receiver</i> object. Returns true if the connection succeeds; otherwise returns false.</p>
<p>You must use the <tt>SIGNAL()</tt> and <tt>SLOT()</tt> macros when specifying the <i>signal</i> and the <i>method</i>, for example:</p>
<pre>         QLabel *label = new QLabel;
         QScrollBar *scrollBar = new QScrollBar;
         QObject::connect(scrollBar, SIGNAL(valueChanged(int)),
                          label,  SLOT(setNum(int)));</pre>
<p>This example ensures that the label always displays the current scroll bar value. Note that the signal and slots parameters must not contain any variable names, only the type. E.g&#x2e; the following would not work and return false:</p>
<pre>         // WRONG
         QObject::connect(scrollBar, SIGNAL(valueChanged(int value)),
                          label, SLOT(setNum(int value)));</pre>
<p>A signal can also be connected to another signal:</p>
<pre>         class MyWidget : public QWidget
         {
             Q_OBJECT

         public:
             MyWidget();

         signals:
             void buttonClicked();

         private:
             QPushButton *myButton;
         };

         MyWidget::MyWidget()
         {
             myButton = new QPushButton(this);
             connect(myButton, SIGNAL(clicked()),
                     this, SIGNAL(buttonClicked()));
         }</pre>
<p>In this example, the <tt>MyWidget</tt> constructor relays a signal from a private member variable, and makes it available under a name that relates to <tt>MyWidget</tt>.</p>
<p>A signal can be connected to many slots and signals. Many signals can be connected to one slot.</p>
<p>If a signal is connected to several slots, the slots are activated in an arbitrary order when the signal is emitted.</p>
<p>The function returns true if it successfully connects the signal to the slot. It will return false if it cannot create the connection, for example, if <a href="qobject.html">QObject</a> is unable to verify the existence of either <i>signal</i> or <i>method</i>, or if their signatures aren't compatible.</p>
<p>A signal is emitted for every connection you make, so if you duplicate a connection, two signals will be emitted. You can always break a connection using <a href="qobject.html#disconnect">disconnect</a>().</p>
<p>The optional <i>type</i> parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message</p>
<pre>         QObject::connect: Cannot queue arguments of type 'MyType'
         (Make sure 'MyType' is registered using qRegisterMetaType().)</pre>
<p>call <a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>() to register the data type before you establish the connection.</p>
<p><b>Note:</b> This function is <a href="threads.html#thread-safe">thread-safe</a>.</p>
<p>See also <a href="qobject.html#disconnect">disconnect</a>(), <a href="qobject.html#sender">sender</a>(), and <a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>().</p>
<h3 class="fn"><a name="connect-2"></a>bool QObject::connect ( const QObject * <i>sender</i>, const char * <i>signal</i>, const char * <i>method</i>, <a href="qt.html#ConnectionType-enum">Qt::ConnectionType</a> <i>type</i> = Qt::AutoCompatConnection ) const</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Connects <i>signal</i> from the <i>sender</i> object to this object's <i>method</i>.</p>
<p>Equivalent to connect(<i>sender</i>, <i>signal</i>, <tt>this</tt>, <i>method</i>, <i>type</i>).</p>
<p>Every connection you make emits a signal, so duplicate connections emit two signals. You can break a connection using <a href="qobject.html#disconnect">disconnect</a>().</p>
<p><b>Note:</b> This function is <a href="threads.html#thread-safe">thread-safe</a>.</p>
<p>See also <a href="qobject.html#disconnect">disconnect</a>().</p>
<h3 class="fn"><a name="connectNotify"></a>void QObject::connectNotify ( const char * <i>signal</i> )&nbsp;&nbsp;<tt> [virtual protected]</tt></h3>
<p>This virtual function is called when something has been connected to <i>signal</i> in this object.</p>
<p>If you want to compare <i>signal</i> with a specific signal, use <a href="qlatin1string.html">QLatin1String</a> and the <tt>SIGNAL()</tt> macro as follows:</p>
<pre>         if (QLatin1String(signal) == SIGNAL(valueChanged(int))) {
             // signal is valueChanged(int)
         }</pre>
<p>If the signal contains multiple parameters or parameters that contain spaces, call <a href="qmetaobject.html#normalizedSignature">QMetaObject::normalizedSignature</a>() on the result of the <tt>SIGNAL()</tt> macro.</p>
<p><b>Warning:</b> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</p>
<p>See also <a href="qobject.html#connect">connect</a>() and <a href="qobject.html#disconnectNotify">disconnectNotify</a>().</p>
<h3 class="fn"><a name="customEvent"></a>void QObject::customEvent ( <a href="qevent.html">QEvent</a> * <i>event</i> )&nbsp;&nbsp;<tt> [virtual protected]</tt></h3>
<p>This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the <a href="qevent.html#Type-enum">QEvent::User</a> item of the <a href="qevent.html#Type-enum">QEvent::Type</a> enum, and is typically a <a href="qevent.html">QEvent</a> subclass. The event is passed in the <i>event</i> parameter.</p>
<p>See also <a href="qobject.html#event">event</a>() and <a href="qevent.html">QEvent</a>.</p>
<h3 class="fn"><a name="deleteLater"></a>void QObject::deleteLater ()&nbsp;&nbsp;<tt> [slot]</tt></h3>
<p>Schedules this object for deletion.</p>
<p>The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g&#x2e; deleteLater() is called on an object before <a href="qcoreapplication.html#exec">QCoreApplication::exec</a>()), the object will be deleted once the event loop is started.</p>
<p>Note that entering and leaving a new event loop (e.g&#x2e;, by opening a modal dialog) will <i>not</i> perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which deleteLater() was called.</p>
<p><b>Note:</b> It is safe to call this function more than once; when the first deferred deletion event is delivered, any pending events for the object are removed from the event queue.</p>
<p>See also <a href="qobject.html#destroyed">destroyed</a>() and <a href="qpointer.html">QPointer</a>.</p>
<h3 class="fn"><a name="destroyed"></a>void QObject::destroyed ( QObject * <i>obj</i> = 0 )&nbsp;&nbsp;<tt> [signal]</tt></h3>
<p>This signal is emitted immediately before the object <i>obj</i> is destroyed, and can not be blocked.</p>
<p>All the objects's children are destroyed immediately after this signal is emitted.</p>
<p>See also <a href="qobject.html#deleteLater">deleteLater</a>() and <a href="qpointer.html">QPointer</a>.</p>
<h3 class="fn"><a name="disconnect"></a>bool QObject::disconnect ( const QObject * <i>sender</i>, const char * <i>signal</i>, const QObject * <i>receiver</i>, const char * <i>method</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Disconnects <i>signal</i> in object <i>sender</i> from <i>method</i> in object <i>receiver</i>. Returns true if the connection is successfully broken; otherwise returns false.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<p>disconnect() is typically used in three ways, as the following examples demonstrate.</p>
<ol type="1">
<li>Disconnect everything connected to an object's signals:<pre>        disconnect(myObject, 0, 0, 0);</pre>
<p>equivalent to the non-static overloaded function</p>
<pre>        myObject-&gt;disconnect();</pre>
</li>
<li>Disconnect everything connected to a specific signal:<pre>        disconnect(myObject, SIGNAL(mySignal()), 0, 0);</pre>
<p>equivalent to the non-static overloaded function</p>
<pre>        myObject-&gt;disconnect(SIGNAL(mySignal()));</pre>
</li>
<li>Disconnect a specific receiver:<pre>        disconnect(myObject, 0, myReceiver, 0);</pre>
<p>equivalent to the non-static overloaded function</p>
<pre>        myObject-&gt;disconnect(myReceiver);</pre>
</li>
</ol>
<p>0 may be used as a wildcard, meaning &quot;any signal&quot;, &quot;any receiving object&quot;, or &quot;any slot in the receiving object&quot;, respectively.</p>
<p>The <i>sender</i> may never be 0. (You cannot disconnect signals from more than one object in a single call.)</p>
<p>If <i>signal</i> is 0, it disconnects <i>receiver</i> and <i>method</i> from any signal. If not, only the specified signal is disconnected.</p>
<p>If <i>receiver</i> is 0, it disconnects anything connected to <i>signal</i>. If not, slots in objects other than <i>receiver</i> are not disconnected.</p>
<p>If <i>method</i> is 0, it disconnects anything that is connected to <i>receiver</i>. If not, only slots named <i>method</i> will be disconnected, and all other slots are left alone. The <i>method</i> must be 0 if <i>receiver</i> is left out, so you cannot disconnect a specifically-named slot on all objects.</p>
<p><b>Note:</b> This function is <a href="threads.html#thread-safe">thread-safe</a>.</p>
<p>See also <a href="qobject.html#connect">connect</a>().</p>
<h3 class="fn"><a name="disconnect-2"></a>bool QObject::disconnect ( const char * <i>signal</i> = 0, const QObject * <i>receiver</i> = 0, const char * <i>method</i> = 0 )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Disconnects <i>signal</i> from <i>method</i> of <i>receiver</i>.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<p><b>Note:</b> This function is <a href="threads.html#thread-safe">thread-safe</a>.</p>
<h3 class="fn"><a name="disconnect-3"></a>bool QObject::disconnect ( const QObject * <i>receiver</i>, const char * <i>method</i> = 0 )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Disconnects all signals in this object from <i>receiver</i>'s <i>method</i>.</p>
<p>A signal-slot connection is removed when either of the objects involved are destroyed.</p>
<h3 class="fn"><a name="disconnectNotify"></a>void QObject::disconnectNotify ( const char * <i>signal</i> )&nbsp;&nbsp;<tt> [virtual protected]</tt></h3>
<p>This virtual function is called when something has been disconnected from <i>signal</i> in this object.</p>
<p>See <a href="qobject.html#connectNotify">connectNotify</a>() for an example of how to compare <i>signal</i> with a specific signal.</p>
<p><b>Warning:</b> This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.</p>
<p>See also <a href="qobject.html#disconnect">disconnect</a>() and <a href="qobject.html#connectNotify">connectNotify</a>().</p>
<h3 class="fn"><a name="dumpObjectInfo"></a>void QObject::dumpObjectInfo ()</h3>
<p>Dumps information about signal connections, etc. for this object to the debug output.</p>
<p>This function is useful for debugging, but does nothing if the library has been compiled in release mode (i.e&#x2e; without debugging information).</p>
<p>See also <a href="qobject.html#dumpObjectTree">dumpObjectTree</a>().</p>
<h3 class="fn"><a name="dumpObjectTree"></a>void QObject::dumpObjectTree ()</h3>
<p>Dumps a tree of children to the debug output.</p>
<p>This function is useful for debugging, but does nothing if the library has been compiled in release mode (i.e&#x2e; without debugging information).</p>
<p>See also <a href="qobject.html#dumpObjectInfo">dumpObjectInfo</a>().</p>
<h3 class="fn"><a name="dynamicPropertyNames"></a><a href="qlist.html">QList</a>&lt;<a href="qbytearray.html">QByteArray</a>&gt; QObject::dynamicPropertyNames () const</h3>
<p>Returns the names of all properties that were dynamically added to the object using <a href="qobject.html#setProperty">setProperty</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="event"></a>bool QObject::event ( <a href="qevent.html">QEvent</a> * <i>e</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This virtual function receives events to an object and should return true if the event <i>e</i> was recognized and processed.</p>
<p>The event() function can be reimplemented to customize the behavior of an object.</p>
<p>See also <a href="qobject.html#installEventFilter">installEventFilter</a>(), <a href="qobject.html#timerEvent">timerEvent</a>(), <a href="qcoreapplication.html#sendEvent">QApplication::sendEvent</a>(), <a href="qcoreapplication.html#postEvent">QApplication::postEvent</a>(), and <a href="qwidget.html#event">QWidget::event</a>().</p>
<h3 class="fn"><a name="eventFilter"></a>bool QObject::eventFilter ( QObject * <i>watched</i>, <a href="qevent.html">QEvent</a> * <i>event</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Filters events if this object has been installed as an event filter for the <i>watched</i> object.</p>
<p>In your reimplementation of this function, if you want to filter the <i>event</i> out, i.e&#x2e; stop it being handled further, return true; otherwise return false.</p>
<p>Example:</p>
<pre>         class MainWindow : public QMainWindow
         {
         public:
             MainWindow();

         protected:
             bool eventFilter(QObject *obj, QEvent *ev);

         private:
             QTextEdit *textEdit;
         };

         MainWindow::MainWindow()
         {
             textEdit = new QTextEdit;
             setCentralWidget(textEdit);

             textEdit-&gt;installEventFilter(this);
         }

         bool MainWindow::eventFilter(QObject *obj, QEvent *event)
         {
             if (obj == textEdit) {
                 if (event-&gt;type() == QEvent::KeyPress) {
                     QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(event);
                     qDebug() &lt;&lt; &quot;Ate key press&quot; &lt;&lt; keyEvent-&gt;key();
                     return true;
                 } else {
                     return false;
                 }
             } else {
                 // pass the event on to the parent class
                 return QMainWindow::eventFilter(obj, event);
             }
         }</pre>
<p>Notice in the example above that unhandled events are passed to the base class's eventFilter() function, since the base class might have reimplemented eventFilter() for its own internal purposes.</p>
<p><b>Warning:</b> If you delete the receiver object in this function, be sure to return true. Otherwise, Qt will forward the event to the deleted object and the program might crash.</p>
<p>See also <a href="qobject.html#installEventFilter">installEventFilter</a>().</p>
<h3 class="fn"><a name="findChild"></a>T QObject::findChild ( const <a href="qstring.html">QString</a> &amp; <i>name</i> = QString() ) const</h3>
<p>Returns the child of this object that can be cast into type T and that is called <i>name</i>, or 0 if there is no such object. Omitting the <i>name</i> argument causes all object names to be matched. The search is performed recursively.</p>
<p>If there is more than one child matching the search, the most direct ancestor is returned. If there are several direct ancestors, it is undefined which one will be returned. In that case, <a href="qobject.html#findChildren">findChildren</a>() should be used.</p>
<p>This example returns a child <a href="qpushbutton.html">QPushButton</a> of <tt>parentWidget</tt> named <tt>&quot;button1&quot;</tt>:</p>
<pre>         QPushButton *button = parentWidget-&gt;findChild&lt;QPushButton *&gt;(&quot;button1&quot;);</pre>
<p>This example returns a <a href="qlistwidget.html">QListWidget</a> child of <tt>parentWidget</tt>:</p>
<pre>         QListWidget *list = parentWidget-&gt;findChild&lt;QListWidget *&gt;();</pre>
<p><b>Warning:</b> This function is not available with MSVC 6. Use <a href="qobject.html#qFindChild">qFindChild</a>() instead if you need to support that version of the compiler.</p>
<p>See also <a href="qobject.html#findChildren">findChildren</a>() and <a href="qobject.html#qFindChild">qFindChild</a>().</p>
<h3 class="fn"><a name="findChildren"></a><a href="qlist.html">QList</a>&lt;T&gt; QObject::findChildren ( const <a href="qstring.html">QString</a> &amp; <i>name</i> = QString() ) const</h3>
<p>Returns all children of this object with the given <i>name</i> that can be cast to type T, or an empty list if there are no such objects. Omitting the <i>name</i> argument causes all object names to be matched. The search is performed recursively.</p>
<p>The following example shows how to find a list of child <a href="qwidget.html">QWidget</a>s of the specified <tt>parentWidget</tt> named <tt>widgetname</tt>:</p>
<pre>         QList&lt;QWidget *&gt; widgets = parentWidget.findChildren&lt;QWidget *&gt;(&quot;widgetname&quot;);</pre>
<p>This example returns all <tt>QPushButton</tt>s that are children of <tt>parentWidget</tt>:</p>
<pre>         QList&lt;QPushButton *&gt; allPButtons = parentWidget.findChildren&lt;QPushButton *&gt;();</pre>
<p><b>Warning:</b> This function is not available with MSVC 6. Use <a href="qobject.html#qFindChildren">qFindChildren</a>() instead if you need to support that version of the compiler.</p>
<p>See also <a href="qobject.html#findChild">findChild</a>() and <a href="qobject.html#qFindChildren">qFindChildren</a>().</p>
<h3 class="fn"><a name="findChildren-2"></a><a href="qlist.html">QList</a>&lt;T&gt; QObject::findChildren ( const <a href="qregexp.html">QRegExp</a> &amp; <i>regExp</i> ) const</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Returns the children of this object that can be cast to type T and that have names matching the regular expression <i>regExp</i>, or an empty list if there are no such objects. The search is performed recursively.</p>
<p><b>Warning:</b> This function is not available with MSVC 6. Use <a href="qobject.html#qFindChildren">qFindChildren</a>() instead if you need to support that version of the compiler.</p>
<h3 class="fn"><a name="inherits"></a>bool QObject::inherits ( const char * <i>className</i> ) const</h3>
<p>Returns true if this object is an instance of a class that inherits <i>className</i> or a <a href="qobject.html">QObject</a> subclass that inherits <i>className</i>; otherwise returns false.</p>
<p>A class is considered to inherit itself.</p>
<p>Example:</p>
<pre>         QTimer *timer = new QTimer;         // QTimer inherits QObject
         timer-&gt;inherits(&quot;QTimer&quot;);          // returns true
         timer-&gt;inherits(&quot;QObject&quot;);         // returns true
         timer-&gt;inherits(&quot;QAbstractButton&quot;); // returns false

         // QLayout inherits QObject and QLayoutItem
         QLayout *layout = new QLayout;
         layout-&gt;inherits(&quot;QObject&quot;);        // returns true
         layout-&gt;inherits(&quot;QLayoutItem&quot;);    // returns false</pre>
<p>(<a href="qlayoutitem.html">QLayoutItem</a> is not a <a href="qobject.html">QObject</a>.)</p>
<p>Consider using qobject_cast&lt;Type *&gt;(object) instead. The method is both faster and safer.</p>
<p>See also <a href="qobject.html#metaObject">metaObject</a>() and <a href="qobject.html#qobject_cast">qobject_cast</a>().</p>
<h3 class="fn"><a name="installEventFilter"></a>void QObject::installEventFilter ( QObject * <i>filterObj</i> )</h3>
<p>Installs an event filter <i>filterObj</i> on this object. For example:</p>
<pre>     monitoredObj-&gt;installEventFilter(filterObj);</pre>
<p>An event filter is an object that receives all events that are sent to this object. The filter can either stop the event or forward it to this object. The event filter <i>filterObj</i> receives events via its <a href="qobject.html#eventFilter">eventFilter</a>() function. The <a href="qobject.html#eventFilter">eventFilter</a>() function must return true if the event should be filtered, (i.e&#x2e; stopped); otherwise it must return false.</p>
<p>If multiple event filters are installed on a single object, the filter that was installed last is activated first.</p>
<p>Here's a <tt>KeyPressEater</tt> class that eats the key presses of its monitored objects:</p>
<pre>         class KeyPressEater : public QObject
         {
             Q_OBJECT
             ...

         protected:
             bool eventFilter(QObject *obj, QEvent *event);
         };

         bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)
         {
             if (event-&gt;type() == QEvent::KeyPress) {
                 QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event);
                 qDebug(&quot;Ate key press %d&quot;, keyEvent-&gt;key());
                 return true;
             } else {
                 // standard event processing
                 return QObject::eventFilter(obj, event);
             }
         }</pre>
<p>And here's how to install it on two widgets:</p>
<pre>         KeyPressEater *keyPressEater = new KeyPressEater(this);
         QPushButton *pushButton = new QPushButton(this);
         QListView *listView = new QListView(this);

         pushButton-&gt;installEventFilter(keyPressEater);
         listView-&gt;installEventFilter(keyPressEater);</pre>
<p>The <a href="qshortcut.html">QShortcut</a> class, for example, uses this technique to intercept shortcut key presses.</p>
<p><b>Warning:</b> If you delete the receiver object in your <a href="qobject.html#eventFilter">eventFilter</a>() function, be sure to return true. If you return false, Qt sends the event to the deleted object and the program will crash.</p>
<p>Note that the filtering object must be in the same thread as this object. If <i>filterObj</i> is in a different thread, this function does nothing. If either <i>filterObj</i> or this object are moved to a different thread after calling this function, the event filter will not be called until both objects have the same thread affinity again (it is <i>not</i> removed).</p>
<p>See also <a href="qobject.html#removeEventFilter">removeEventFilter</a>(), <a href="qobject.html#eventFilter">eventFilter</a>(), and <a href="qobject.html#event">event</a>().</p>
<h3 class="fn"><a name="isWidgetType"></a>bool QObject::isWidgetType () const</h3>
<p>Returns true if the object is a widget; otherwise returns false.</p>
<p>Calling this function is equivalent to calling inherits(&quot;<a href="qwidget.html">QWidget</a>&quot;), except that it is much faster.</p>
<h3 class="fn"><a name="killTimer"></a>void QObject::killTimer ( int <i>id</i> )</h3>
<p>Kills the timer with timer identifier, <i>id</i>.</p>
<p>The timer identifier is returned by <a href="qobject.html#startTimer">startTimer</a>() when a timer event is started.</p>
<p>See also <a href="qobject.html#timerEvent">timerEvent</a>() and <a href="qobject.html#startTimer">startTimer</a>().</p>
<h3 class="fn"><a name="metaObject"></a>const <a href="qmetaobject.html">QMetaObject</a> * QObject::metaObject () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns a pointer to the meta-object of this object.</p>
<p>A meta-object contains information about a class that inherits <a href="qobject.html">QObject</a>, e.g&#x2e; class name, superclass name, properties, signals and slots. Every <a href="qobject.html">QObject</a> subclass that contains the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro will have a meta-object.</p>
<p>The meta-object information is required by the signal/slot connection mechanism and the property system. The <a href="qobject.html#inherits">inherits</a>() function also makes use of the meta-object.</p>
<p>If you have no pointer to an actual object instance but still want to access the meta-object of a class, you can use <a href="qobject.html#staticMetaObject-var">staticMetaObject</a>.</p>
<p>Example:</p>
<pre>         QObject *obj = new QPushButton;
         obj-&gt;metaObject()-&gt;className();             // returns &quot;QPushButton&quot;

         QPushButton::staticMetaObject.className();  // returns &quot;QPushButton&quot;</pre>
<p>See also <a href="qobject.html#staticMetaObject-var">staticMetaObject</a>.</p>
<h3 class="fn"><a name="moveToThread"></a>void QObject::moveToThread ( <a href="qthread.html">QThread</a> * <i>targetThread</i> )</h3>
<p>Changes the thread affinity for this object and its children. The object cannot be moved if it has a parent. Event processing will continue in the <i>targetThread</i>.</p>
<p>To move an object to the main thread, use <a href="qcoreapplication.html#instance">QApplication::instance</a>() to retrieve a pointer to the current application, and then use <a href="qobject.html#thread">QApplication::thread</a>() to retrieve the thread in which the application lives. For example:</p>
<pre>         myObject-&gt;moveToThread(QApplication::instance()-&gt;thread());</pre>
<p>If <i>targetThread</i> is zero, all event processing for this object and its children stops.</p>
<p>Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the <i>targetThread</i>. As a result, constantly moving an object between threads can postpone timer events indefinitely.</p>
<p>A <a href="qevent.html#Type-enum">QEvent::ThreadChange</a> event is sent to this object just before the thread affinity is changed. You can handle this event to perform any special processing. Note that any new events that are posted to this object will be handled in the <i>targetThread</i>.</p>
<p><b>Warning:</b> This function is <i>not</i> thread-safe; the current thread must be same as the current thread affinity. In other words, this function can only &quot;push&quot; an object from the current thread to another thread, it cannot &quot;pull&quot; an object from any arbitrary thread to the current thread.</p>
<p>See also <a href="qobject.html#thread">thread</a>().</p>
<h3 class="fn"><a name="parent"></a>QObject * QObject::parent () const</h3>
<p>Returns a pointer to the parent object.</p>
<p>See also <a href="qobject.html#setParent">setParent</a>() and <a href="qobject.html#children">children</a>().</p>
<h3 class="fn"><a name="property"></a><a href="qvariant.html">QVariant</a> QObject::property ( const char * <i>name</i> ) const</h3>
<p>Returns the value of the object's <i>name</i> property.</p>
<p>If no such property exists, the returned variant is invalid.</p>
<p>Information about all available properties is provided through the <a href="qobject.html#metaObject">metaObject</a>() and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>
<p>See also <a href="qobject.html#setProperty">setProperty</a>(), <a href="qvariant.html#isValid">QVariant::isValid</a>(), <a href="qobject.html#metaObject">metaObject</a>(), and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>
<h3 class="fn"><a name="receivers"></a>int QObject::receivers ( const char * <i>signal</i> ) const&nbsp;&nbsp;<tt> [protected]</tt></h3>
<p>Returns the number of receivers connected to the <i>signal</i>.</p>
<p>Since both slots and signals can be used as receivers for signals, and the same connections can be made many times, the number of receivers is the same as the number of connections made from this signal.</p>
<p>When calling this function, you can use the <tt>SIGNAL()</tt> macro to pass a specific signal:</p>
<pre>         if (receivers(SIGNAL(valueChanged(QByteArray))) &gt; 0) {
             QByteArray data;
             get_the_value(&amp;data);       // expensive operation
             emit valueChanged(data);
         }</pre>
<p>As the code snippet above illustrates, you can use this function to avoid emitting a signal that nobody listens to.</p>
<p><b>Warning:</b> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</p>
<h3 class="fn"><a name="removeEventFilter"></a>void QObject::removeEventFilter ( QObject * <i>obj</i> )</h3>
<p>Removes an event filter object <i>obj</i> from this object. The request is ignored if such an event filter has not been installed.</p>
<p>All event filters for this object are automatically removed when this object is destroyed.</p>
<p>It is always safe to remove an event filter, even during event filter activation (i.e&#x2e; from the <a href="qobject.html#eventFilter">eventFilter</a>() function).</p>
<p>See also <a href="qobject.html#installEventFilter">installEventFilter</a>(), <a href="qobject.html#eventFilter">eventFilter</a>(), and <a href="qobject.html#event">event</a>().</p>
<h3 class="fn"><a name="sender"></a>QObject * QObject::sender () const&nbsp;&nbsp;<tt> [protected]</tt></h3>
<p>Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise it returns 0. The pointer is valid only during the execution of the slot that calls this function.</p>
<p>The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.</p>
<p><b>Warning:</b> This function violates the object-oriented principle of modularity. However, getting access to the sender might be useful when many signals are connected to a single slot.</p>
<p>See also <a href="qsignalmapper.html">QSignalMapper</a>.</p>
<h3 class="fn"><a name="setParent"></a>void QObject::setParent ( QObject * <i>parent</i> )</h3>
<p>Makes the object a child of <i>parent</i>.</p>
<p>See also <a href="qobject.html#parent">parent</a>() and <a href="qwidget.html#setParent">QWidget::setParent</a>().</p>
<h3 class="fn"><a name="setProperty"></a>bool QObject::setProperty ( const char * <i>name</i>, const <a href="qvariant.html">QVariant</a> &amp; <i>value</i> )</h3>
<p>Sets the value of the object's <i>name</i> property to <i>value</i>.</p>
<p>If the property is defined in the class using Q_PROPERTY then true is returned on success and false otherwise. If the property is not defined using Q_PROPERTY, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.</p>
<p>Information about all available properties is provided through the <a href="qobject.html#metaObject">metaObject</a>() and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>
<p>Dynamic properties can be queried again using <a href="qobject.html#property">property</a>() and can be removed by setting the property value to an invalid <a href="qvariant.html">QVariant</a>. Changing the value of a dynamic property causes a <a href="qdynamicpropertychangeevent.html">QDynamicPropertyChangeEvent</a> to be sent to the object.</p>
<p><b>Note:</b> Dynamic properties starting with &quot;_q_&quot; are reserved for internal purposes.</p>
<p>See also <a href="qobject.html#property">property</a>(), <a href="qobject.html#metaObject">metaObject</a>(), and <a href="qobject.html#dynamicPropertyNames">dynamicPropertyNames</a>().</p>
<h3 class="fn"><a name="signalsBlocked"></a>bool QObject::signalsBlocked () const</h3>
<p>Returns true if signals are blocked; otherwise returns false.</p>
<p>Signals are not blocked by default.</p>
<p>See also <a href="qobject.html#blockSignals">blockSignals</a>().</p>
<h3 class="fn"><a name="startTimer"></a>int QObject::startTimer ( int <i>interval</i> )</h3>
<p>Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.</p>
<p>A timer event will occur every <i>interval</i> milliseconds until <a href="qobject.html#killTimer">killTimer</a>() is called. If <i>interval</i> is 0, then the timer event occurs once every time there are no more window system events to process.</p>
<p>The virtual <a href="qobject.html#timerEvent">timerEvent</a>() function is called with the <a href="qtimerevent.html">QTimerEvent</a> event parameter class when a timer event occurs. Reimplement this function to get timer events.</p>
<p>If multiple timers are running, the <a href="qtimerevent.html#timerId">QTimerEvent::timerId</a>() can be used to find out which timer was activated.</p>
<p>Example:</p>
<pre>         class MyObject : public QObject
         {
             Q_OBJECT

         public:
             MyObject(QObject *parent = 0);

         protected:
             void timerEvent(QTimerEvent *event);
         };

         MyObject::MyObject(QObject *parent)
             : QObject(parent)
         {
             startTimer(50);     // 50-millisecond timer
             startTimer(1000);   // 1-second timer
             startTimer(60000);  // 1-minute timer
         }

         void MyObject::timerEvent(QTimerEvent *event)
         {
             qDebug() &lt;&lt; &quot;Timer ID:&quot; &lt;&lt; event-&gt;timerId();
         }</pre>
<p>Note that <a href="qtimer.html">QTimer</a>'s accuracy depends on the underlying operating system and hardware. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.</p>
<p>The <a href="qtimer.html">QTimer</a> class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a <a href="qbasictimer.html">QBasicTimer</a> class that is more lightweight than <a href="qtimer.html">QTimer</a> and less clumsy than using timer IDs directly.</p>
<p>See also <a href="qobject.html#timerEvent">timerEvent</a>(), <a href="qobject.html#killTimer">killTimer</a>(), and <a href="qtimer.html#singleShot">QTimer::singleShot</a>().</p>
<h3 class="fn"><a name="thread"></a><a href="qthread.html">QThread</a> * QObject::thread () const</h3>
<p>Returns the thread in which the object lives.</p>
<p>See also <a href="qobject.html#moveToThread">moveToThread</a>().</p>
<h3 class="fn"><a name="timerEvent"></a>void QObject::timerEvent ( <a href="qtimerevent.html">QTimerEvent</a> * <i>event</i> )&nbsp;&nbsp;<tt> [virtual protected]</tt></h3>
<p>This event handler can be reimplemented in a subclass to receive timer events for the object.</p>
<p><a href="qtimer.html">QTimer</a> provides a higher-level interface to the timer functionality, and also more general information about timers. The timer event is passed in the <i>event</i> parameter.</p>
<p>See also <a href="qobject.html#startTimer">startTimer</a>(), <a href="qobject.html#killTimer">killTimer</a>(), and <a href="qobject.html#event">event</a>().</p>
<h3 class="fn"><a name="tr"></a><a href="qstring.html">QString</a> QObject::tr ( const char * <i>sourceText</i>, const char * <i>comment</i> = 0, int <i>n</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a translated version of <i>sourceText</i>, or <i>sourceText</i> itself if there is no appropriate translated version. The translation context is Object with <i>comment</i> (0 by default). All <a href="qobject.html">QObject</a> subclasses using the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro automatically have a reimplementation of this function with the subclass name as context.</p>
<p>You can set the encoding for <i>sourceText</i> by calling <a href="qtextcodec.html#setCodecForTr">QTextCodec::setCodecForTr</a>(). By default <i>sourceText</i> is assumed to be in Latin-1 encoding.</p>
<p>Example:</p>
<pre>         MyWindow::MyWindow()
         {
             QLabel *nameLabel = new QLabel(tr(&quot;Name:&quot;));
             QLabel *addressLabel = new QLabel(tr(&quot;Address:&quot;, &quot;i.e. a postal address&quot;));
             ...
         }</pre>
<p>If <i>n</i> &gt;= 0, all occurrences of <tt>%n</tt> in the resulting string are replaced with a decimal representation of <i>n</i>. In addition, depending on <i>n</i>'s value, the translation text may vary.</p>
<p>Example:</p>
<pre>         int n = messages.count();
         showMessage(tr(&quot;%n message(s) saved&quot;, &quot;&quot;, n));</pre>
<p>The table below shows what string is returned depending on the active translation:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th></th><th colspan="3">Active Translation</th></tr>
<tr valign="top" class="qt-style"><th><i>n</i></th><th>No Translation</th><th>French</th><th>English</th></tr></thead>
<tr valign="top" class="odd"><td>0</td><td>&quot;0 message(s) saved&quot;</td><td>&quot;0 message sauvegard&quot;</td><td>&quot;0 message<b>s</b> saved&quot;</td></tr>
<tr valign="top" class="even"><td>1</td><td>&quot;1 message(s) saved&quot;</td><td>&quot;1 message sauvegard&quot;</td><td>&quot;1 message saved&quot;</td></tr>
<tr valign="top" class="odd"><td>2</td><td>&quot;2 message(s) saved&quot;</td><td>&quot;2 message<b>s</b> sauvegard<b>s</b>&quot;</td><td>&quot;2 message<b>s</b> saved&quot;</td></tr>
<tr valign="top" class="even"><td>37</td><td>&quot;37 message(s) saved&quot;</td><td>&quot;37 message<b>s</b> sauvegard<b>s</b>&quot;</td><td>&quot;37 message<b>s</b> saved&quot;</td></tr>
</table></p>
<p>This idiom is more flexible than the traditional approach, i.e&#x2e;,</p>
<pre>         n == 1 ? tr(&quot;%n message saved&quot;) : tr(&quot;%n messages saved&quot;)</pre>
<p>because it also works with target languages that have several plural forms (e.g&#x2e;, Irish has a special &quot;dual&quot; form that should be used when <tt>n</tt> is 2), and it handles the <i>n</i> == 0 case correctly for languages such as French that require the singular. See the <a href="linguist-manual.html">Qt Linguist Manual</a> for details.</p>
<p>Instead of <tt>%n</tt>, you can use <tt>%Ln</tt> to produce a localized representation of <i>n</i>. The conversion uses the default local, set using QLocal::setDefault(). (If no default locale was specified, the &quot;C&quot; locale is used.)</p>
<p><b>Warning:</b> This method is reentrant only if all translators are installed <i>before</i> calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.</p>
<p>See also <a href="qobject.html#trUtf8">trUtf8</a>(), <a href="qcoreapplication.html#translate">QApplication::translate</a>(), <a href="qtextcodec.html#setCodecForTr">QTextCodec::setCodecForTr</a>(), and <a href="i18n.html">Internationalization with Qt</a>.</p>
<h3 class="fn"><a name="trUtf8"></a><a href="qstring.html">QString</a> QObject::trUtf8 ( const char * <i>sourceText</i>, const char * <i>comment</i> = 0, int <i>n</i> = -1 )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a translated version of <i>sourceText</i>, or QString::fromUtf8(<i>sourceText</i>) if there is no appropriate version. It is otherwise identical to tr(<i>sourceText</i>, <i>comment</i>, <i>n</i>).</p>
<p><b>Warning:</b> This method is reentrant only if all translators are installed <i>before</i> calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.</p>
<p><b>Warning:</b> For portability reasons, we recommend that you use escape sequences for specifying non-ASCII characters in string literals to trUtf8(). For example:</p>
<pre>         label-&gt;setText(tr(&quot;F\374r \310lise&quot;));</pre>
<p>See also <a href="qobject.html#tr">tr</a>(), <a href="qcoreapplication.html#translate">QApplication::translate</a>(), and <a href="i18n.html">Internationalization with Qt</a>.</p>
<hr />
<h2>Member Variable Documentation</h2>
<h3 class="fn"><a name="staticMetaObject-var"></a>const <a href="qmetaobject.html">QMetaObject</a> QObject::staticMetaObject</h3>
<p>This variable stores the meta-object for the class.</p>
<p>A meta-object contains information about a class that inherits <a href="qobject.html">QObject</a>, e.g&#x2e; class name, superclass name, properties, signals and slots. Every class that contains the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro will also have a meta-object.</p>
<p>The meta-object information is required by the signal/slot connection mechanism and the property system. The <a href="qobject.html#inherits">inherits</a>() function also makes use of the meta-object.</p>
<p>If you have a pointer to an object, you can use <a href="qobject.html#metaObject">metaObject</a>() to retrieve the meta-object associated with that object.</p>
<p>Example:</p>
<pre>         QPushButton::staticMetaObject.className();  // returns &quot;QPushButton&quot;

         QObject *obj = new QPushButton;
         obj-&gt;metaObject()-&gt;className();             // returns &quot;QPushButton&quot;</pre>
<p>See also <a href="qobject.html#metaObject">metaObject</a>().</p>
<hr />
<h2>Related Non-Members</h2>
<h3 class="fn"><a name="QObjectList-typedef"></a>typedef QObjectList</h3>
<p>Synonym for <a href="qlist.html">QList</a>&lt;<a href="qobject.html">QObject</a> *&gt;.</p>
<h3 class="fn"><a name="qFindChild"></a>T qFindChild ( const QObject * <i>obj</i>, const <a href="qstring.html">QString</a> &amp; <i>name</i> )</h3>
<p>This function is equivalent to <i>obj</i>-&gt;<a href="qobject.html#findChild">findChild</a>&lt;T&gt;(<i>name</i>). It is provided as a work-around for MSVC 6, which doesn't support member template functions.</p>
<p>See also <a href="qobject.html#findChild">QObject::findChild</a>().</p>
<h3 class="fn"><a name="qFindChildren"></a><a href="qlist.html">QList</a>&lt;T&gt; qFindChildren ( const QObject * <i>obj</i>, const <a href="qstring.html">QString</a> &amp; <i>name</i> )</h3>
<p>This function is equivalent to <i>obj</i>-&gt;<a href="qobject.html#findChildren">findChildren</a>&lt;T&gt;(<i>name</i>). It is provided as a work-around for MSVC 6, which doesn't support member template functions.</p>
<p>See also <a href="qobject.html#findChildren">QObject::findChildren</a>().</p>
<h3 class="fn"><a name="qFindChildren-6"></a><a href="qlist.html">QList</a>&lt;T&gt; qFindChildren ( const QObject * <i>obj</i>, const <a href="qregexp.html">QRegExp</a> &amp; <i>regExp</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>This function is equivalent to <i>obj</i>-&gt;<a href="qobject.html#findChildren">findChildren</a>&lt;T&gt;(<i>regExp</i>). It is provided as a work-around for MSVC 6, which doesn't support member template functions.</p>
<h3 class="fn"><a name="qobject_cast"></a>T qobject_cast ( QObject * <i>object</i> )</h3>
<p>Returns the given <i>object</i> cast to type T if the object is of type T (or of a subclass); otherwise returns 0.</p>
<p>The class T must inherit (directly or indirectly) <a href="qobject.html">QObject</a> and be declared with the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro.</p>
<p>A class is considered to inherit itself.</p>
<p>Example:</p>
<pre>         QObject *obj = new QTimer;          // QTimer inherits QObject

         QTimer *timer = qobject_cast&lt;QTimer *&gt;(obj);
         // timer == (QObject *)obj

         QAbstractButton *button = qobject_cast&lt;QAbstractButton *&gt;(obj);
         // button == 0</pre>
<p>The qobject_cast() function behaves similarly to the standard C++ <tt>dynamic_cast()</tt>, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries.</p>
<p>qobject_cast() can also be used in conjunction with interfaces; see the <a href="tools-plugandpaint.html">Plug &amp; Paint</a> example for details.</p>
<p><b>Warning:</b> If T isn't declared with the <a href="qobject.html#Q_OBJECT">Q_OBJECT</a> macro, this function's return value is undefined.</p>
<p>See also <a href="qobject.html#inherits">QObject::inherits</a>().</p>
<hr />
<h2>Macro Documentation</h2>
<h3 class="fn"><a name="Q_CLASSINFO"></a>Q_CLASSINFO (  <i>Name</i>,  <i>Value</i> )</h3>
<p>This macro associates extra information to the class, which is available using <a href="qobject.html#metaObject">QObject::metaObject</a>(). Except for the <a href="activeqt.html#activeqt">ActiveQt</a> extension, Qt doesn't use this information.</p>
<p>The extra information takes the form of a <i>Name</i> string and a <i>Value</i> literal string.</p>
<p>Example:</p>
<pre>         class MyClass : public QObject
         {
             Q_OBJECT
             Q_CLASSINFO(&quot;Author&quot;, &quot;Pierre Gendron&quot;)
             Q_CLASSINFO(&quot;URL&quot;, &quot;http://www.my-organization.qc.ca&quot;)

         public:
             ...
         };</pre>
<p>See also <a href="qmetaobject.html#classInfo">QMetaObject::classInfo</a>().</p>
<h3 class="fn"><a name="Q_ENUMS"></a>Q_ENUMS ( ... )</h3>
<p>This macro registers one or several enum types to the meta-object system.</p>
<p>For example:</p>
<pre>     class MyClass : public QObject
     {
         Q_OBJECT
         Q_ENUMS(Priority)

     public:
         MyClass(QObject *parent = 0);
         ~MyClass();

         enum Priority { High, Low, VeryHigh, VeryLow };
         void setPriority(Priority priority);
         Priority priority() const;
     };</pre>
<p>If you want to register an enum that is declared in another class, the enum must be fully qualified with the name of the class defining it. In addition, the class <i>defining</i> the enum has to inherit <a href="qobject.html">QObject</a> as well as declare the enum using Q_ENUMS().</p>
<p>See also <a href="properties.html">Qt's Property System</a>.</p>
<h3 class="fn"><a name="Q_FLAGS"></a>Q_FLAGS ( ... )</h3>
<p>This macro registers one or several &quot;flags&quot; types to the meta-object system.</p>
<p>Example:</p>
<pre>         Q_FLAGS(Options Alignment)</pre>
<p>See also <a href="properties.html">Qt's Property System</a>.</p>
<h3 class="fn"><a name="Q_INTERFACES"></a>Q_INTERFACES ( ... )</h3>
<p>This macro tells Qt which interfaces the class implements. This is used when implementing plugins.</p>
<p>Example:</p>
<pre> class BasicToolsPlugin : public QObject,
                          public BrushInterface,
                          public ShapeInterface,
                          public FilterInterface
 {
     Q_OBJECT
     Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)

 public:
     ...
 };</pre>
<p>See the <a href="tools-plugandpaintplugins-basictools.html">Plug &amp; Paint Basic Tools</a> example for details.</p>
<p>See also <a href="qtplugin.html#Q_DECLARE_INTERFACE">Q_DECLARE_INTERFACE</a>(), <a href="qtplugin.html#Q_EXPORT_PLUGIN2">Q_EXPORT_PLUGIN2</a>(), and <a href="plugins-howto.html">How to Create Qt Plugins</a>.</p>
<h3 class="fn"><a name="Q_OBJECT"></a>Q_OBJECT</h3>
<p>The Q_OBJECT macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.</p>
<p>For example:</p>
<pre> #include &lt;QObject&gt;

 class Counter : public QObject
 {
     Q_OBJECT

 public:
     Counter() { m_value = 0; }

     int value() const { return m_value; }

 public slots:
     void setValue(int value);

 signals:
     void valueChanged(int newValue);

 private:
     int m_value;
 };</pre>
<p>See also <a href="metaobjects.html">Meta-Object System</a>, <a href="signalsandslots.html">Signals and Slots</a>, and <a href="properties.html">Qt's Property System</a>.</p>
<h3 class="fn"><a name="Q_PROPERTY"></a>Q_PROPERTY ( ... )</h3>
<p>This macro is used for declaring properties in classes that inherit <a href="qobject.html">QObject</a>. Properties behave like class data members, but they have additional features accessible through the <a href="metaobjects.html">Meta-Object System</a>.</p>
<pre>         Q_PROPERTY(type name
                    READ getFunction
                    [WRITE setFunction]
                    [RESET resetFunction]
                    [DESIGNABLE bool]
                    [SCRIPTABLE bool]
                    [STORED bool]
                    [USER bool])</pre>
<p>The property name and type and the <tt>READ</tt> function are required. The type can be any type supported by <a href="qvariant.html">QVariant</a>, or it can be a user-defined type. The other items are optional, but a <tt>WRITE</tt> function is common. The attributes default to true except <tt>USER</tt>, which defaults to false.</p>
<p>For example:</p>
<pre>         Q_PROPERTY(QString title READ title WRITE setTitle USER true)</pre>
<p>For more details about how to use this macro, and a more detailed example of its use, see the discussion on <a href="properties.html">Qt's Property System</a>.</p>
<p>See also <a href="properties.html">Qt's Property System</a>.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008 <a href="trolltech.html">Trolltech</a></td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.4.0</div></td>
</tr></table></div></address></body>
</html>
