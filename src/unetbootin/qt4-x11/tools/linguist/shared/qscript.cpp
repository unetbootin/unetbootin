// This file was generated by qlalr - DO NOT EDIT!
/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** Contact: Qt Software Information (qt-info@nokia.com)
**
** This file is part of the Qt Linguist of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial Usage
** Licensees holding valid Qt Commercial licenses may use this file in
** accordance with the Qt Commercial License Agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Nokia.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain
** additional rights. These rights are described in the Nokia Qt LGPL
** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
** package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
** If you are unsure which license is appropriate for your use, please
** contact the sales department at qt-sales@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

class QScriptGrammar
{
public:
  enum {
    EOF_SYMBOL = 0,
    T_AND = 1,
    T_AND_AND = 2,
    T_AND_EQ = 3,
    T_AUTOMATIC_SEMICOLON = 62,
    T_BREAK = 4,
    T_CASE = 5,
    T_CATCH = 6,
    T_COLON = 7,
    T_COMMA = 8,
    T_CONST = 81,
    T_CONTINUE = 9,
    T_DEBUGGER = 82,
    T_DEFAULT = 10,
    T_DELETE = 11,
    T_DIVIDE_ = 12,
    T_DIVIDE_EQ = 13,
    T_DO = 14,
    T_DOT = 15,
    T_ELSE = 16,
    T_EQ = 17,
    T_EQ_EQ = 18,
    T_EQ_EQ_EQ = 19,
    T_FALSE = 80,
    T_FINALLY = 20,
    T_FOR = 21,
    T_FUNCTION = 22,
    T_GE = 23,
    T_GT = 24,
    T_GT_GT = 25,
    T_GT_GT_EQ = 26,
    T_GT_GT_GT = 27,
    T_GT_GT_GT_EQ = 28,
    T_IDENTIFIER = 29,
    T_IF = 30,
    T_IN = 31,
    T_INSTANCEOF = 32,
    T_LBRACE = 33,
    T_LBRACKET = 34,
    T_LE = 35,
    T_LPAREN = 36,
    T_LT = 37,
    T_LT_LT = 38,
    T_LT_LT_EQ = 39,
    T_MINUS = 40,
    T_MINUS_EQ = 41,
    T_MINUS_MINUS = 42,
    T_NEW = 43,
    T_NOT = 44,
    T_NOT_EQ = 45,
    T_NOT_EQ_EQ = 46,
    T_NULL = 78,
    T_NUMERIC_LITERAL = 47,
    T_OR = 48,
    T_OR_EQ = 49,
    T_OR_OR = 50,
    T_PLUS = 51,
    T_PLUS_EQ = 52,
    T_PLUS_PLUS = 53,
    T_QUESTION = 54,
    T_RBRACE = 55,
    T_RBRACKET = 56,
    T_REMAINDER = 57,
    T_REMAINDER_EQ = 58,
    T_RESERVED_WORD = 83,
    T_RETURN = 59,
    T_RPAREN = 60,
    T_SEMICOLON = 61,
    T_STAR = 63,
    T_STAR_EQ = 64,
    T_STRING_LITERAL = 65,
    T_SWITCH = 66,
    T_THIS = 67,
    T_THROW = 68,
    T_TILDE = 69,
    T_TRUE = 79,
    T_TRY = 70,
    T_TYPEOF = 71,
    T_VAR = 72,
    T_VOID = 73,
    T_WHILE = 74,
    T_WITH = 75,
    T_XOR = 76,
    T_XOR_EQ = 77,

    ACCEPT_STATE = 236,
    RULE_COUNT = 267,
    STATE_COUNT = 465,
    TERMINAL_COUNT = 84,
    NON_TERMINAL_COUNT = 88,

    GOTO_INDEX_OFFSET = 465,
    GOTO_INFO_OFFSET = 1374,
    GOTO_CHECK_OFFSET = 1374
  };

  static const char  *const spell [];
  static const int            lhs [];
  static const int            rhs [];
  static const int   goto_default [];
  static const int action_default [];
  static const int   action_index [];
  static const int    action_info [];
  static const int   action_check [];

  static inline int nt_action (int state, int nt)
  {
    const int *const goto_index = &action_index [GOTO_INDEX_OFFSET];
    const int *const goto_check = &action_check [GOTO_CHECK_OFFSET];

    const int yyn = goto_index [state] + nt;

    if (yyn < 0 || goto_check [yyn] != nt)
      return goto_default [nt];

    const int *const goto_info = &action_info [GOTO_INFO_OFFSET];
    return goto_info [yyn];
  }

  static inline int t_action (int state, int token)
  {
    const int yyn = action_index [state] + token;

    if (yyn < 0 || action_check [yyn] != token)
      return - action_default [state];

    return action_info [yyn];
  }
};


const char *const QScriptGrammar::spell [] = {
  "end of file", "&", "&&", "&=", "break", "case", "catch", ":", ";", "continue", 
  "default", "delete", "/", "/=", "do", ".", "else", "=", "==", "===", 
  "finally", "for", "function", ">=", ">", ">>", ">>=", ">>>", ">>>=", "identifier", 
  "if", "in", "instanceof", "{", "[", "<=", "(", "<", "<<", "<<=", 
  "-", "-=", "--", "new", "!", "!=", "!==", "numeric literal", "|", "|=", 
  "||", "+", "+=", "++", "?", "}", "]", "%", "%=", "return", 
  ")", ";", 0, "*", "*=", "string literal", "switch", "this", "throw", "~", 
  "try", "typeof", "var", "void", "while", "with", "^", "^=", "null", "true", 
  "false", "const", "debugger", "reserved word"};

const int QScriptGrammar::lhs [] = {
  85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 
  85, 85, 85, 85, 87, 87, 91, 91, 86, 86, 
  92, 92, 93, 93, 93, 93, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 95, 95, 96, 
  96, 96, 96, 96, 99, 99, 100, 100, 100, 100, 
  98, 98, 101, 101, 102, 102, 103, 103, 103, 104, 
  104, 104, 104, 104, 104, 104, 104, 104, 104, 105, 
  105, 105, 105, 106, 106, 106, 107, 107, 107, 107, 
  108, 108, 108, 108, 108, 108, 108, 109, 109, 109, 
  109, 109, 109, 110, 110, 110, 110, 110, 111, 111, 
  111, 111, 111, 112, 112, 113, 113, 114, 114, 115, 
  115, 116, 116, 117, 117, 118, 118, 119, 119, 120, 
  120, 121, 121, 122, 122, 123, 123, 90, 90, 124, 
  124, 125, 125, 125, 125, 125, 125, 125, 125, 125, 
  125, 125, 125, 89, 89, 126, 126, 127, 127, 128, 
  128, 129, 129, 129, 129, 129, 129, 129, 129, 129, 
  129, 129, 129, 129, 129, 129, 130, 146, 146, 145, 
  145, 131, 131, 147, 147, 148, 148, 150, 150, 149, 
  151, 154, 152, 152, 155, 153, 153, 132, 133, 133, 
  134, 134, 135, 135, 135, 135, 135, 135, 135, 136, 
  136, 136, 136, 137, 137, 137, 137, 138, 138, 139, 
  141, 156, 156, 159, 159, 157, 157, 160, 158, 140, 
  142, 142, 143, 143, 143, 161, 162, 144, 163, 97, 
  167, 167, 164, 164, 165, 165, 168, 84, 169, 169, 
  170, 170, 166, 166, 88, 88, 171};

const int QScriptGrammar:: rhs[] = {
  1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 
  3, 5, 3, 3, 2, 4, 1, 2, 0, 1, 
  3, 5, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 4, 3, 3, 1, 2, 2, 2, 4, 3, 
  2, 3, 1, 3, 1, 1, 1, 2, 2, 1, 
  2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 
  3, 3, 3, 1, 3, 3, 1, 3, 3, 3, 
  1, 3, 3, 3, 3, 3, 3, 1, 3, 3, 
  3, 3, 3, 1, 3, 3, 3, 3, 1, 3, 
  3, 3, 3, 1, 3, 1, 3, 1, 3, 1, 
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 
  3, 1, 3, 1, 5, 1, 5, 1, 3, 1, 
  3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 3, 0, 1, 1, 3, 0, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 3, 1, 2, 0, 
  1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 
  2, 2, 0, 1, 2, 0, 1, 1, 2, 2, 
  7, 5, 7, 7, 5, 9, 10, 7, 8, 2, 
  2, 3, 3, 2, 2, 3, 3, 3, 3, 5, 
  5, 3, 5, 1, 2, 0, 1, 4, 3, 3, 
  3, 3, 3, 3, 4, 5, 2, 1, 8, 8, 
  1, 3, 0, 1, 0, 1, 1, 1, 1, 2, 
  1, 1, 0, 1, 0, 1, 2};

const int QScriptGrammar::action_default [] = {
  0, 97, 164, 128, 136, 132, 172, 179, 76, 148, 
  178, 186, 174, 124, 0, 175, 262, 61, 176, 177, 
  182, 77, 140, 144, 65, 94, 75, 80, 60, 0, 
  114, 180, 101, 259, 258, 261, 183, 0, 194, 0, 
  248, 0, 8, 9, 0, 5, 0, 263, 2, 0, 
  265, 19, 0, 0, 0, 0, 0, 3, 6, 0, 
  0, 166, 208, 7, 0, 1, 0, 0, 4, 0, 
  0, 195, 0, 0, 0, 184, 185, 90, 0, 173, 
  181, 0, 0, 77, 96, 263, 2, 265, 79, 78, 
  0, 0, 0, 92, 93, 91, 0, 264, 253, 254, 
  0, 251, 0, 252, 0, 255, 256, 0, 257, 250, 
  260, 0, 266, 0, 26, 27, 28, 29, 30, 31, 
  32, 33, 34, 35, 36, 37, 38, 39, 40, 23, 
  41, 42, 43, 44, 45, 25, 46, 47, 24, 48, 
  49, 50, 51, 52, 53, 54, 55, 56, 57, 0, 
  21, 0, 0, 0, 22, 13, 95, 0, 125, 0, 
  0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 
  105, 0, 0, 0, 99, 100, 98, 103, 107, 106, 
  104, 102, 117, 116, 118, 0, 133, 0, 129, 68, 
  0, 0, 0, 70, 59, 58, 0, 0, 69, 165, 
  0, 73, 71, 0, 72, 74, 209, 210, 0, 161, 
  154, 152, 159, 160, 158, 157, 163, 156, 155, 153, 
  162, 149, 0, 137, 0, 0, 141, 0, 0, 145, 
  67, 0, 0, 63, 0, 62, 267, 224, 0, 225, 
  226, 227, 220, 0, 221, 222, 223, 81, 0, 0, 
  0, 0, 0, 213, 214, 170, 168, 130, 138, 134, 
  150, 126, 171, 0, 77, 142, 146, 119, 108, 0, 
  0, 127, 0, 0, 0, 0, 120, 0, 0, 0, 
  0, 0, 112, 110, 113, 111, 109, 122, 121, 123, 
  0, 135, 0, 131, 0, 169, 77, 0, 151, 166, 
  167, 0, 166, 0, 0, 216, 0, 0, 0, 218, 
  0, 139, 0, 0, 143, 0, 0, 147, 206, 0, 
  198, 207, 201, 0, 205, 0, 166, 199, 0, 166, 
  0, 0, 217, 0, 0, 0, 219, 264, 253, 0, 
  0, 255, 0, 249, 0, 240, 0, 0, 0, 212, 
  0, 211, 188, 191, 0, 27, 30, 31, 248, 34, 
  35, 5, 39, 40, 2, 41, 44, 3, 6, 166, 
  7, 48, 1, 50, 4, 52, 53, 54, 55, 56, 
  57, 189, 187, 65, 66, 64, 0, 228, 229, 0, 
  0, 0, 231, 236, 234, 237, 0, 0, 235, 236, 
  0, 232, 0, 233, 190, 239, 0, 190, 238, 0, 
  241, 242, 0, 190, 243, 244, 0, 0, 245, 0, 
  0, 0, 246, 247, 83, 82, 0, 0, 0, 215, 
  0, 0, 0, 230, 0, 20, 0, 17, 19, 11, 
  0, 16, 12, 18, 15, 10, 0, 14, 87, 85, 
  89, 86, 84, 88, 203, 196, 0, 204, 200, 0, 
  202, 192, 0, 193, 197};

const int QScriptGrammar::goto_default [] = {
  29, 28, 436, 434, 113, 14, 2, 435, 112, 111, 
  114, 193, 24, 17, 189, 26, 8, 200, 21, 27, 
  77, 25, 1, 32, 30, 267, 13, 261, 3, 257, 
  5, 259, 4, 258, 22, 265, 23, 266, 9, 260, 
  256, 297, 386, 262, 263, 35, 6, 79, 12, 15, 
  18, 19, 10, 7, 31, 80, 20, 36, 75, 76, 
  11, 354, 353, 78, 456, 455, 319, 320, 458, 322, 
  457, 321, 392, 396, 399, 395, 394, 414, 415, 16, 
  100, 107, 96, 99, 106, 108, 33, 0};

const int QScriptGrammar::action_index [] = {
  1210, 59, -84, 71, 41, -1, -84, -84, 148, -84, 
  -84, -84, -84, 201, 130, -84, -84, -84, -84, -84, 
  -84, 343, 67, 62, 122, 109, -84, -84, -84, 85, 
  273, -84, 184, -84, 1210, -84, -84, 119, -84, 112, 
  -84, 521, -84, -84, 1130, -84, 45, 54, 58, 38, 
  1290, 50, 521, 521, 521, 376, 521, -84, -84, 521, 
  521, 521, -84, -84, 25, -84, 521, 521, -84, 43, 
  521, -84, 521, 18, 15, -84, -84, -84, 24, -84, 
  -84, 521, 521, 64, 153, 27, -84, 1050, -84, -84, 
  521, 521, 521, -84, -84, -84, 28, -84, 37, 55, 
  19, -84, 33, -84, 34, 1210, -84, 16, 1210, -84, 
  -84, 39, 52, -3, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, 521, 
  -84, 1050, 125, 521, -84, -84, 155, 521, 189, 521, 
  521, 521, 521, 248, 521, 521, 521, 521, 521, 521, 
  243, 521, 521, 521, 75, 82, 94, 177, 184, 184, 
  184, 184, 263, 283, 298, 521, 44, 521, 77, -84, 
  970, 521, 817, -84, -84, -84, 95, 521, -84, -84, 
  93, -84, -84, 521, -84, -84, -84, -84, 521, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, 521, 41, 521, 521, 68, 66, 521, -84, 
  -84, 970, 521, -84, 103, -84, -84, -84, 63, -84, 
  -84, -84, -84, 69, -84, -84, -84, -84, -27, 12, 
  521, 92, 100, -84, -84, 890, -84, 31, -13, -45, 
  -84, 210, 32, -28, 387, 20, 73, 304, 117, -5, 
  521, 212, 521, 521, 521, 521, 213, 521, 521, 521, 
  521, 521, 151, 150, 176, 158, 168, 304, 304, 228, 
  521, -72, 521, 4, 521, -84, 306, 521, -84, 521, 
  8, -50, 521, -48, 1130, -84, 521, 80, 1130, -84, 
  521, -33, 521, 521, 5, 48, 521, -84, 17, 88, 
  11, -84, -84, 521, -84, -29, 521, -84, -41, 521, 
  -39, 1130, -84, 521, 87, 1130, -84, -8, -2, -35, 
  10, 1210, -16, -84, 1130, -84, 521, 86, 1130, -14, 
  1130, -84, -84, 1130, -36, 107, -21, 165, 3, 521, 
  1130, 6, 14, 61, 7, -19, 448, -4, -6, 671, 
  29, 13, 23, 521, 30, -10, 521, 9, 521, -30, 
  -18, -84, -84, 164, -84, -84, 46, -84, -84, 521, 
  111, -24, -84, 36, -84, 40, 99, 521, -84, 21, 
  22, -84, -11, -84, 1130, -84, 106, 1130, -84, 178, 
  -84, -84, 98, 1130, 57, -84, 56, 60, -84, 51, 
  26, 35, -84, -84, -84, -84, 521, 97, 1130, -84, 
  521, 90, 1130, -84, 79, 76, 744, -84, 49, -84, 
  594, -84, -84, -84, -84, -84, 83, -84, -84, -84, 
  -84, -84, -84, -84, 42, -84, 162, -84, -84, 521, 
  -84, -84, 53, -84, -84, 

  -61, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -4, -88, -88, 22, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -51, -88, -88, -88, -88, -88, 
  -88, 105, -88, -88, -12, -88, -88, -88, -88, -88, 
  -7, -88, 35, 132, 62, 154, 79, -88, -88, 100, 
  75, 36, -88, -88, -88, -88, 37, 70, -88, -1, 
  86, -88, 92, -88, -88, -88, -88, -88, -88, -88, 
  -88, 90, 95, -88, -88, -88, -88, -88, -88, -88, 
  87, 82, 74, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -47, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, 28, 
  -88, 20, -88, 19, -88, -88, -88, 39, -88, 42, 
  43, 106, 61, -88, 63, 55, 52, 53, 91, 125, 
  -88, 120, 123, 118, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, 116, -88, 59, -88, -88, 
  16, 18, 15, -88, -88, -88, -88, 21, -88, -88, 
  -88, -88, -88, 24, -88, -88, -88, -88, 38, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, 97, -88, 115, 25, -88, -88, 26, -88, 
  -88, 111, 14, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  23, -88, -88, -88, -88, 108, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  160, -88, 171, 163, 145, 179, -88, 135, 45, 41, 
  66, 80, -88, -88, -88, -88, -88, -88, -88, -88, 
  172, -88, 156, -88, 142, -88, -88, 144, -88, 122, 
  -88, -88, 114, -88, -23, -88, 48, -88, 29, -88, 
  224, -88, 157, 175, -88, -88, 182, -88, -88, -88, 
  -88, -88, -88, 183, -88, -21, 134, -88, -88, 49, 
  -88, 3, -88, 44, -88, 2, -88, -88, -37, -88, 
  -88, -31, -88, -88, 10, -88, 47, -88, 17, -88, 
  27, -88, -88, 13, -88, -88, -88, -88, -88, 117, 
  6, -88, -88, -88, -88, -88, 154, -88, -88, 1, 
  -88, -88, -88, 7, -88, -35, 137, -88, 141, -88, 
  -88, -88, -88, -6, -88, -88, -88, -88, -88, 78, 
  -88, -88, -88, -88, -88, -69, -88, 11, -88, -59, 
  -88, -88, -88, -88, 83, -88, -88, 56, -88, -88, 
  -88, -88, -88, -40, -58, -88, -88, -29, -88, -88, 
  -88, -45, -88, -88, -88, -88, -3, -88, -42, -88, 
  -5, -88, -32, -88, -88, -88, 9, -88, 8, -88, 
  -2, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, 12, 
  -88, -88, -56, -88, -88};

const int QScriptGrammar::action_info [] = {
  318, -25, 350, -45, 292, 270, 426, 310, -194, 393, 
  -32, 302, 304, -37, 344, 290, 197, 346, 430, 382, 
  329, 331, 310, 413, 318, 340, 397, 101, 338, 404, 
  -49, 292, 270, 299, 323, 290, -24, -51, -195, 343, 
  294, 397, 333, 341, 403, 397, 149, 249, 250, 389, 
  255, 430, 155, 454, 426, 316, 97, 437, 437, 459, 
  151, 389, 103, 102, 98, 344, 101, 105, 413, 222, 
  222, 109, 157, 228, 346, 187, 413, 417, 157, 104, 
  420, 255, 454, 337, 443, 236, 421, 438, 197, 185, 
  97, 197, 419, 413, 197, 197, 325, -263, 197, 81, 
  197, 203, 0, 197, 416, 197, 88, 388, 387, 400, 
  82, 197, 224, 407, 197, 81, 225, 89, 417, 197, 
  187, 90, 81, 312, 241, 240, 82, 313, 0, 0, 
  246, 245, 153, 82, 81, 439, 238, 231, 197, 0, 
  308, 243, 171, 447, 172, 82, 348, 335, 238, 326, 
  432, 198, 252, 204, 401, 173, 232, 428, 192, 235, 
  0, 254, 253, 190, 0, 90, 91, 90, 239, 237, 
  462, 391, 92, 244, 242, 171, 171, 172, 172, 231, 
  239, 237, 191, 171, 192, 172, 197, 0, 173, 173, 
  0, 207, 206, 171, 243, 172, 173, 0, 232, 0, 
  192, 171, 171, 172, 172, 0, 173, 159, 160, 171, 
  91, 172, 91, 0, 173, 173, 92, 0, 92, 159, 
  160, 0, 173, 463, 461, 0, 244, 242, 272, 273, 
  272, 273, 0, 0, 161, 162, 277, 278, 0, 411, 
  410, 0, 0, 0, 0, 279, 161, 162, 280, 0, 
  281, 277, 278, 0, 0, 274, 275, 274, 275, 0, 
  279, 0, 0, 280, 0, 281, 0, 0, 171, 0, 
  172, 164, 165, 0, 0, 0, 0, 0, 0, 166, 
  167, 173, 0, 168, 0, 169, 164, 165, 0, 0, 
  0, 0, 0, 0, 166, 167, 164, 165, 168, 0, 
  169, 0, 0, 0, 166, 167, 164, 165, 168, 209, 
  169, 0, 0, 0, 166, 167, 0, 0, 168, 210, 
  169, 164, 165, 211, 0, 0, 0, 277, 278, 166, 
  167, 0, 212, 168, 213, 169, 279, 0, 0, 280, 
  0, 281, 0, 0, 0, 214, 209, 215, 88, 0, 
  0, 0, 0, 0, 0, 216, 210, 0, 217, 89, 
  211, 0, 0, 0, 218, 0, 0, 0, 0, 212, 
  219, 213, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 214, 220, 215, 88, 0, 0, 42, 43, 
  209, 0, 216, 0, 0, 217, 89, 0, 85, 0, 
  210, 218, 0, 0, 211, 86, 0, 219, 0, 87, 
  51, 0, 52, 212, 0, 213, 0, 0, 306, 55, 
  220, 0, 0, 58, 0, 0, 214, 0, 215, 88, 
  0, 0, 0, 0, 0, 0, 216, 0, 0, 217, 
  89, 63, 0, 65, 0, 218, 0, 0, 0, 0, 
  0, 219, 0, 0, 57, 68, 45, 0, 0, 0, 
  42, 43, 0, 0, 220, 0, 0, 0, 0, 0, 
  85, 0, 0, 0, 0, 0, 0, 86, 0, 0, 
  0, 87, 51, 0, 52, 0, 0, 0, 0, 0, 
  0, 55, 0, 0, 0, 58, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 63, 0, 65, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 57, 68, 45, 0, 
  0, 0, 41, 42, 43, 0, 0, 0, 0, 0, 
  0, 0, 0, 85, 0, 0, 0, 0, 0, 0, 
  86, 0, 0, 0, 87, 51, 0, 52, 0, 0, 
  0, 53, 0, 54, 55, 56, 0, 0, 58, 0, 
  0, 0, 59, 0, 60, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 63, 0, 65, 0, 
  67, 0, 70, 0, 72, 0, 0, 0, 0, 57, 
  68, 45, 0, 0, 0, 41, 42, 43, 0, 0, 
  0, 0, 0, 0, 0, 0, 85, 0, 0, 0, 
  0, 0, 0, 86, 0, 0, 0, 87, 51, 0, 
  52, 0, 0, 0, 53, 0, 54, 55, 56, 0, 
  0, 58, 0, 0, 0, 59, 0, 60, 0, 0, 
  442, 0, 0, 0, 0, 0, 0, 0, 0, 63, 
  0, 65, 0, 67, 0, 70, 0, 72, 0, 0, 
  0, 0, 57, 68, 45, 0, 0, 0, -47, 0, 
  0, 0, 41, 42, 43, 0, 0, 0, 0, 0, 
  0, 0, 0, 85, 0, 0, 0, 0, 0, 0, 
  86, 0, 0, 0, 87, 51, 0, 52, 0, 0, 
  0, 53, 0, 54, 55, 56, 0, 0, 58, 0, 
  0, 0, 59, 0, 60, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 63, 0, 65, 0, 
  67, 0, 70, 0, 72, 0, 0, 0, 0, 57, 
  68, 45, 0, 0, 0, 41, 42, 43, 0, 0, 
  0, 0, 0, 0, 0, 0, 85, 0, 0, 0, 
  0, 0, 0, 86, 0, 0, 0, 87, 51, 0, 
  52, 0, 0, 0, 53, 0, 54, 55, 56, 0, 
  0, 58, 0, 0, 0, 59, 0, 60, 0, 0, 
  445, 0, 0, 0, 0, 0, 0, 0, 0, 63, 
  0, 65, 0, 67, 0, 70, 0, 72, 0, 0, 
  0, 0, 57, 68, 45, 0, 0, 0, 41, 42, 
  43, 0, 0, 0, 0, 0, 0, 0, 0, 85, 
  0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 
  87, 51, 0, 52, 0, 0, 0, 53, 0, 54, 
  55, 56, 0, 0, 58, 0, 0, 0, 59, 0, 
  60, 0, 0, 0, 0, 0, 0, 202, 0, 0, 
  0, 0, 63, 0, 65, 0, 67, 0, 70, 0, 
  72, 0, 0, 0, 0, 57, 68, 45, 0, 0, 
  0, 41, 42, 43, 0, 0, 0, 0, 0, 0, 
  0, 0, 85, 0, 0, 0, 0, 0, 0, 86, 
  0, 0, 0, 87, 51, 0, 52, 0, 0, 0, 
  53, 0, 54, 55, 56, 0, 0, 58, 0, 0, 
  0, 59, 0, 60, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 63, 0, 65, 0, 67, 
  0, 70, 269, 72, 0, 0, 0, 0, 57, 68, 
  45, 0, 0, 0, 115, 116, 117, 0, 0, 119, 
  121, 122, 0, 0, 123, 0, 124, 0, 0, 0, 
  126, 127, 128, 0, 0, 0, 0, 0, 0, 195, 
  130, 131, 132, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 133, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 137, 
  0, 0, 0, 0, 0, 0, 139, 140, 141, 0, 
  143, 144, 145, 146, 147, 148, 0, 0, 134, 142, 
  125, 118, 120, 136, 115, 116, 117, 0, 0, 119, 
  121, 122, 0, 0, 123, 0, 124, 0, 0, 0, 
  126, 127, 128, 0, 0, 0, 0, 0, 0, 129, 
  130, 131, 132, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 133, 0, 0, 0, 135, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 137, 
  0, 0, 0, 0, 0, 138, 139, 140, 141, 0, 
  143, 144, 145, 146, 147, 148, 0, 0, 134, 142, 
  125, 118, 120, 136, 37, 0, 0, 0, 0, 39, 
  0, 41, 42, 43, 44, 0, 0, 0, 0, 0, 
  0, 46, 85, 0, 0, 0, 0, 0, 0, 48, 
  49, 0, 0, 50, 51, 0, 52, 0, 0, 0, 
  53, 0, 54, 55, 56, 0, 0, 58, 0, 0, 
  0, 59, 0, 60, 0, 0, 0, 0, 0, 61, 
  0, 62, 0, 0, 0, 63, 64, 65, 66, 67, 
  69, 70, 71, 72, 73, 74, 0, 0, 57, 68, 
  45, 38, 40, 0, 37, 0, 0, 0, 0, 39, 
  0, 41, 42, 43, 44, 0, 0, 0, 0, 0, 
  0, 46, 47, 0, 0, 0, 0, 0, 0, 48, 
  49, 0, 0, 50, 51, 0, 52, 0, 0, 0, 
  53, 0, 54, 55, 56, 0, 0, 58, 0, 0, 
  0, 59, 0, 60, 0, 0, 0, 0, 0, 61, 
  0, 62, 0, 0, 0, 63, 64, 65, 66, 67, 
  69, 70, 71, 72, 73, 74, 0, 0, 57, 68, 
  45, 38, 40, 0, 355, 116, 117, 0, 0, 357, 
  121, 359, 42, 43, 360, 0, 124, 0, 0, 0, 
  126, 362, 363, 0, 0, 0, 0, 0, 0, 364, 
  365, 131, 132, 50, 51, 0, 52, 0, 0, 0, 
  53, 0, 54, 366, 56, 0, 0, 368, 0, 0, 
  0, 59, 0, 60, 0, -190, 0, 0, 0, 369, 
  0, 62, 0, 0, 0, 370, 371, 372, 373, 67, 
  375, 376, 377, 378, 379, 380, 0, 0, 367, 374, 
  361, 356, 358, 136, 

  431, 422, 427, 429, 441, 352, 300, 398, 385, 464, 
  440, 412, 409, 433, 402, 444, 406, 423, 460, 234, 
  418, 201, 305, 196, 34, 154, 194, 199, 251, 152, 
  205, 227, 229, 248, 150, 110, 230, 208, 352, 110, 
  446, 300, 409, 339, 221, 412, 327, 336, 332, 334, 
  342, 248, 347, 307, 300, 345, 0, 83, 381, 83, 
  83, 83, 349, 83, 284, 158, 163, 182, 283, 0, 
  83, 83, 351, 83, 309, 178, 179, 83, 177, 83, 
  83, 83, 449, 390, 83, 184, 170, 188, 83, 285, 
  453, 330, 83, 83, 95, 452, 0, 83, 83, 450, 
  83, 352, 94, 286, 83, 83, 424, 93, 83, 83, 
  83, 84, 425, 83, 180, 83, 156, 408, 83, 300, 
  451, 194, 233, 83, 83, 247, 264, 300, 352, 223, 
  183, 268, 0, 83, 83, 83, 83, 247, 83, 300, 
  176, 83, 174, 83, 405, 175, 186, 0, 181, 226, 
  83, 0, 448, 83, 0, 83, 303, 424, 282, 83, 
  296, 425, 296, 83, 301, 268, 383, 268, 268, 384, 
  288, 0, 0, 0, 83, 83, 328, 0, 83, 268, 
  268, 83, 295, 268, 298, 293, 268, 271, 287, 83, 
  83, 0, 314, 296, 268, 268, 276, 83, 268, 0, 
  296, 296, 268, 291, 289, 268, 268, 0, 0, 0, 
  0, 0, 0, 0, 0, 315, 0, 0, 0, 0, 
  0, 0, 317, 324, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 83, 0, 0, 0, 0, 268, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 311, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0};

const int QScriptGrammar::action_check [] = {
  29, 7, 16, 7, 76, 1, 36, 2, 29, 33, 
  7, 61, 60, 7, 7, 48, 8, 36, 36, 55, 
  61, 60, 2, 33, 29, 60, 5, 29, 36, 7, 
  7, 76, 1, 61, 17, 48, 7, 7, 29, 55, 
  8, 5, 31, 33, 55, 5, 7, 74, 36, 36, 
  36, 36, 55, 29, 36, 7, 29, 8, 8, 17, 
  8, 36, 29, 8, 36, 7, 29, 33, 33, 2, 
  2, 55, 1, 7, 36, 76, 33, 20, 1, 60, 
  29, 36, 29, 29, 8, 0, 60, 8, 8, 48, 
  29, 8, 36, 33, 8, 8, 8, 36, 8, 40, 
  8, 8, -1, 8, 6, 8, 42, 61, 62, 10, 
  51, 8, 50, 7, 8, 40, 54, 53, 20, 8, 
  76, 12, 40, 50, 61, 62, 51, 54, -1, -1, 
  61, 62, 7, 51, 40, 56, 29, 15, 8, -1, 
  60, 29, 25, 60, 27, 51, 60, 60, 29, 61, 
  60, 56, 60, 60, 55, 38, 34, 60, 36, 56, 
  -1, 61, 62, 15, -1, 12, 57, 12, 61, 62, 
  8, 60, 63, 61, 62, 25, 25, 27, 27, 15, 
  61, 62, 34, 25, 36, 27, 8, -1, 38, 38, 
  -1, 61, 62, 25, 29, 27, 38, -1, 34, -1, 
  36, 25, 25, 27, 27, -1, 38, 18, 19, 25, 
  57, 27, 57, -1, 38, 38, 63, -1, 63, 18, 
  19, -1, 38, 61, 62, -1, 61, 62, 18, 19, 
  18, 19, -1, -1, 45, 46, 23, 24, -1, 61, 
  62, -1, -1, -1, -1, 32, 45, 46, 35, -1, 
  37, 23, 24, -1, -1, 45, 46, 45, 46, -1, 
  32, -1, -1, 35, -1, 37, -1, -1, 25, -1, 
  27, 23, 24, -1, -1, -1, -1, -1, -1, 31, 
  32, 38, -1, 35, -1, 37, 23, 24, -1, -1, 
  -1, -1, -1, -1, 31, 32, 23, 24, 35, -1, 
  37, -1, -1, -1, 31, 32, 23, 24, 35, 3, 
  37, -1, -1, -1, 31, 32, -1, -1, 35, 13, 
  37, 23, 24, 17, -1, -1, -1, 23, 24, 31, 
  32, -1, 26, 35, 28, 37, 32, -1, -1, 35, 
  -1, 37, -1, -1, -1, 39, 3, 41, 42, -1, 
  -1, -1, -1, -1, -1, 49, 13, -1, 52, 53, 
  17, -1, -1, -1, 58, -1, -1, -1, -1, 26, 
  64, 28, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, 39, 77, 41, 42, -1, -1, 12, 13, 
  3, -1, 49, -1, -1, 52, 53, -1, 22, -1, 
  13, 58, -1, -1, 17, 29, -1, 64, -1, 33, 
  34, -1, 36, 26, -1, 28, -1, -1, 31, 43, 
  77, -1, -1, 47, -1, -1, 39, -1, 41, 42, 
  -1, -1, -1, -1, -1, -1, 49, -1, -1, 52, 
  53, 65, -1, 67, -1, 58, -1, -1, -1, -1, 
  -1, 64, -1, -1, 78, 79, 80, -1, -1, -1, 
  12, 13, -1, -1, 77, -1, -1, -1, -1, -1, 
  22, -1, -1, -1, -1, -1, -1, 29, -1, -1, 
  -1, 33, 34, -1, 36, -1, -1, -1, -1, -1, 
  -1, 43, -1, -1, -1, 47, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, 65, -1, 67, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, 78, 79, 80, -1, 
  -1, -1, 11, 12, 13, -1, -1, -1, -1, -1, 
  -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, 
  29, -1, -1, -1, 33, 34, -1, 36, -1, -1, 
  -1, 40, -1, 42, 43, 44, -1, -1, 47, -1, 
  -1, -1, 51, -1, 53, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, 65, -1, 67, -1, 
  69, -1, 71, -1, 73, -1, -1, -1, -1, 78, 
  79, 80, -1, -1, -1, 11, 12, 13, -1, -1, 
  -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, 
  -1, -1, -1, 29, -1, -1, -1, 33, 34, -1, 
  36, -1, -1, -1, 40, -1, 42, 43, 44, -1, 
  -1, 47, -1, -1, -1, 51, -1, 53, -1, -1, 
  56, -1, -1, -1, -1, -1, -1, -1, -1, 65, 
  -1, 67, -1, 69, -1, 71, -1, 73, -1, -1, 
  -1, -1, 78, 79, 80, -1, -1, -1, 7, -1, 
  -1, -1, 11, 12, 13, -1, -1, -1, -1, -1, 
  -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, 
  29, -1, -1, -1, 33, 34, -1, 36, -1, -1, 
  -1, 40, -1, 42, 43, 44, -1, -1, 47, -1, 
  -1, -1, 51, -1, 53, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, 65, -1, 67, -1, 
  69, -1, 71, -1, 73, -1, -1, -1, -1, 78, 
  79, 80, -1, -1, -1, 11, 12, 13, -1, -1, 
  -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, 
  -1, -1, -1, 29, -1, -1, -1, 33, 34, -1, 
  36, -1, -1, -1, 40, -1, 42, 43, 44, -1, 
  -1, 47, -1, -1, -1, 51, -1, 53, -1, -1, 
  56, -1, -1, -1, -1, -1, -1, -1, -1, 65, 
  -1, 67, -1, 69, -1, 71, -1, 73, -1, -1, 
  -1, -1, 78, 79, 80, -1, -1, -1, 11, 12, 
  13, -1, -1, -1, -1, -1, -1, -1, -1, 22, 
  -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, 
  33, 34, -1, 36, -1, -1, -1, 40, -1, 42, 
  43, 44, -1, -1, 47, -1, -1, -1, 51, -1, 
  53, -1, -1, -1, -1, -1, -1, 60, -1, -1, 
  -1, -1, 65, -1, 67, -1, 69, -1, 71, -1, 
  73, -1, -1, -1, -1, 78, 79, 80, -1, -1, 
  -1, 11, 12, 13, -1, -1, -1, -1, -1, -1, 
  -1, -1, 22, -1, -1, -1, -1, -1, -1, 29, 
  -1, -1, -1, 33, 34, -1, 36, -1, -1, -1, 
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, 65, -1, 67, -1, 69, 
  -1, 71, 72, 73, -1, -1, -1, -1, 78, 79, 
  80, -1, -1, -1, 4, 5, 6, -1, -1, 9, 
  10, 11, -1, -1, 14, -1, 16, -1, -1, -1, 
  20, 21, 22, -1, -1, -1, -1, -1, -1, 29, 
  30, 31, 32, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 
  -1, -1, -1, -1, -1, -1, 66, 67, 68, -1, 
  70, 71, 72, 73, 74, 75, -1, -1, 78, 79, 
  80, 81, 82, 83, 4, 5, 6, -1, -1, 9, 
  10, 11, -1, -1, 14, -1, 16, -1, -1, -1, 
  20, 21, 22, -1, -1, -1, -1, -1, -1, 29, 
  30, 31, 32, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, 43, -1, -1, -1, 47, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 
  -1, -1, -1, -1, -1, 65, 66, 67, 68, -1, 
  70, 71, 72, 73, 74, 75, -1, -1, 78, 79, 
  80, 81, 82, 83, 4, -1, -1, -1, -1, 9, 
  -1, 11, 12, 13, 14, -1, -1, -1, -1, -1, 
  -1, 21, 22, -1, -1, -1, -1, -1, -1, 29, 
  30, -1, -1, 33, 34, -1, 36, -1, -1, -1, 
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, -1, -1, -1, -1, 59, 
  -1, 61, -1, -1, -1, 65, 66, 67, 68, 69, 
  70, 71, 72, 73, 74, 75, -1, -1, 78, 79, 
  80, 81, 82, -1, 4, -1, -1, -1, -1, 9, 
  -1, 11, 12, 13, 14, -1, -1, -1, -1, -1, 
  -1, 21, 22, -1, -1, -1, -1, -1, -1, 29, 
  30, -1, -1, 33, 34, -1, 36, -1, -1, -1, 
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, -1, -1, -1, -1, 59, 
  -1, 61, -1, -1, -1, 65, 66, 67, 68, 69, 
  70, 71, 72, 73, 74, 75, -1, -1, 78, 79, 
  80, 81, 82, -1, 4, 5, 6, -1, -1, 9, 
  10, 11, 12, 13, 14, -1, 16, -1, -1, -1, 
  20, 21, 22, -1, -1, -1, -1, -1, -1, 29, 
  30, 31, 32, 33, 34, -1, 36, -1, -1, -1, 
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, 55, -1, -1, -1, 59, 
  -1, 61, -1, -1, -1, 65, 66, 67, 68, 69, 
  70, 71, 72, 73, 74, 75, -1, -1, 78, 79, 
  80, 81, 82, 83, 

  5, 46, 5, 45, 6, 45, 5, 76, 14, 65, 
  2, 46, 5, 45, 73, 6, 5, 46, 6, 5, 
  78, 6, 45, 5, 85, 6, 10, 6, 5, 9, 
  6, 6, 6, 45, 6, 86, 14, 41, 45, 86, 
  5, 5, 5, 80, 6, 46, 67, 45, 45, 5, 
  81, 45, 5, 5, 5, 45, -1, 18, 45, 18, 
  18, 18, 45, 18, 23, 26, 24, 24, 23, -1, 
  18, 18, 45, 18, 45, 23, 23, 18, 23, 18, 
  18, 18, 20, 5, 18, 24, 23, 28, 18, 23, 
  20, 42, 18, 18, 20, 20, -1, 18, 18, 20, 
  18, 45, 20, 23, 18, 18, 20, 20, 18, 18, 
  18, 21, 20, 18, 23, 18, 21, 61, 18, 5, 
  20, 10, 11, 18, 18, 20, 18, 5, 45, 32, 
  24, 23, -1, 18, 18, 18, 18, 20, 18, 5, 
  22, 18, 22, 18, 61, 22, 30, -1, 23, 34, 
  18, -1, 20, 18, -1, 18, 42, 20, 23, 18, 
  18, 20, 18, 18, 42, 23, 12, 23, 23, 15, 
  25, -1, -1, -1, 18, 18, 42, -1, 18, 23, 
  23, 18, 40, 23, 40, 29, 23, 27, 25, 18, 
  18, -1, 35, 18, 23, 23, 25, 18, 23, -1, 
  18, 18, 23, 31, 25, 23, 23, -1, -1, -1, 
  -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, 
  -1, -1, 40, 40, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, 18, -1, -1, -1, -1, 23, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1};


#define Q_SCRIPT_REGEXPLITERAL_RULE1 7

#define Q_SCRIPT_REGEXPLITERAL_RULE2 8

#include "translator.h"

#include <QtCore/qdebug.h>
#include <QtCore/qnumeric.h>
#include <QtCore/qstring.h>
#include <QtCore/qtextcodec.h>
#include <QtCore/qvariant.h>

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

QT_BEGIN_NAMESPACE

static void recordMessage(
    Translator *tor, const QString &context, const QString &text, const QString &comment,
    const QString &extracomment, bool plural, const QString &fileName, int lineNo)
{
    TranslatorMessage msg(
        context, text, comment, QString(),
        fileName, lineNo, QStringList(),
        TranslatorMessage::Unfinished, plural);
    msg.setExtraComment(extracomment.simplified());
    tor->replace(msg);
}


namespace QScript
{

class Lexer
{
public:
    Lexer();
    ~Lexer();

    void setCode(const QString &c, int lineno);
    int lex();

    int currentLineNo() const { return yylineno; }
    int currentColumnNo() const { return yycolumn; }

    int startLineNo() const { return startlineno; }
    int startColumnNo() const { return startcolumn; }

    int endLineNo() const { return currentLineNo(); }
    int endColumnNo() const
    { int col = currentColumnNo(); return (col > 0) ? col - 1 : col; }

    bool prevTerminator() const { return terminator; }

    enum State { Start,
                 Identifier,
                 InIdentifier,
                 InSingleLineComment,
                 InMultiLineComment,
                 InNum,
                 InNum0,
                 InHex,
                 InOctal,
                 InDecimal,
                 InExponentIndicator,
                 InExponent,
                 Hex,
                 Octal,
                 Number,
                 String,
                 Eof,
                 InString,
                 InEscapeSequence,
                 InHexEscape,
                 InUnicodeEscape,
                 Other,
                 Bad };

    enum Error {
        NoError,
        IllegalCharacter,
        UnclosedStringLiteral,
        IllegalEscapeSequence,
        IllegalUnicodeEscapeSequence,
        UnclosedComment,
        IllegalExponentIndicator,
        IllegalIdentifier
    };

    enum ParenthesesState {
        IgnoreParentheses,
        CountParentheses,
        BalancedParentheses
    };

    enum RegExpBodyPrefix {
        NoPrefix,
        EqualPrefix
    };

    bool scanRegExp(RegExpBodyPrefix prefix = NoPrefix);

    QString pattern;
    int flags;

    State lexerState() const
        { return state; }

    QString errorMessage() const
        { return errmsg; }
    void setErrorMessage(const QString &err)
        { errmsg = err; }
    void setErrorMessage(const char *err)
        { setErrorMessage(QString::fromLatin1(err)); }

    Error error() const
        { return err; }
    void clearError()
        { err = NoError; }

private:
    int yylineno;
    bool done;
    char *buffer8;
    QChar *buffer16;
    uint size8, size16;
    uint pos8, pos16;
    bool terminator;
    bool restrKeyword;
    // encountered delimiter like "'" and "}" on last run
    bool delimited;
    int stackToken;

    State state;
    void setDone(State s);
    uint pos;
    void shift(uint p);
    int lookupKeyword(const char *);

    bool isWhiteSpace() const;
    bool isLineTerminator() const;
    bool isHexDigit(ushort c) const;
    bool isOctalDigit(ushort c) const;

    int matchPunctuator(ushort c1, ushort c2,
                         ushort c3, ushort c4);
    ushort singleEscape(ushort c) const;
    ushort convertOctal(ushort c1, ushort c2,
                         ushort c3) const;
public:
    static unsigned char convertHex(ushort c1);
    static unsigned char convertHex(ushort c1, ushort c2);
    static QChar convertUnicode(ushort c1, ushort c2,
                                 ushort c3, ushort c4);
    static bool isIdentLetter(ushort c);
    static bool isDecimalDigit(ushort c);

    inline int ival() const { return qsyylval.toInt(); }
    inline double dval() const { return qsyylval.toDouble(); }
    inline QString ustr() const { return qsyylval.toString(); }
    inline QVariant val() const { return qsyylval; }

    const QChar *characterBuffer() const { return buffer16; }
    int characterCount() const { return pos16; }

private:
    void record8(ushort c);
    void record16(QChar c);
    void recordStartPos();

    int findReservedWord(const QChar *buffer, int size) const;

    void syncProhibitAutomaticSemicolon();

    const QChar *code;
    uint length;
    int yycolumn;
    int startlineno;
    int startcolumn;
    int bol;     // begin of line

    QVariant qsyylval;

    // current and following unicode characters
    ushort current, next1, next2, next3;

    struct keyword {
        const char *name;
        int token;
    };

    QString errmsg;
    Error err;

    bool wantRx;
    bool check_reserved;

    ParenthesesState parenthesesState;
    int parenthesesCount;
    bool prohibitAutomaticSemicolon;
};

} // namespace QScript

extern double qstrtod(const char *s00, char const **se, bool *ok);

#define shiftWindowsLineBreak() if(current == '\r' && next1 == '\n') shift(1);

namespace QScript {

static int toDigit(char c)
{
    if ((c >= '0') && (c <= '9'))
        return c - '0';
    else if ((c >= 'a') && (c <= 'z'))
        return 10 + c - 'a';
    else if ((c >= 'A') && (c <= 'Z'))
        return 10 + c - 'A';
    return -1;
}

double integerFromString(const char *buf, int size, int radix)
{
    if (size == 0)
        return qSNaN();

    double sign = 1.0;
    int i = 0;
    if (buf[0] == '+') {
        ++i;
    } else if (buf[0] == '-') {
        sign = -1.0;
        ++i;
    }

    if (((size-i) >= 2) && (buf[i] == '0')) {
        if (((buf[i+1] == 'x') || (buf[i+1] == 'X'))
            && (radix < 34)) {
            if ((radix != 0) && (radix != 16))
                return 0;
            radix = 16;
            i += 2;
        } else {
            if (radix == 0) {
                radix = 8;
                ++i;
            }
        }
    } else if (radix == 0) {
        radix = 10;
    }

    int j = i;
    for ( ; i < size; ++i) {
        int d = toDigit(buf[i]);
        if ((d == -1) || (d >= radix))
            break;
    }
    double result;
    if (j == i) {
        if (!qstrcmp(buf, "Infinity"))
            result = qInf();
        else
            result = qSNaN();
    } else {
        result = 0;
        double multiplier = 1;
        for (--i ; i >= j; --i, multiplier *= radix)
            result += toDigit(buf[i]) * multiplier;
    }
    result *= sign;
    return result;
}

} // namespace QScript

QScript::Lexer::Lexer()
    :
      yylineno(0),
      size8(128), size16(128), restrKeyword(false),
      stackToken(-1), pos(0),
      code(0), length(0),
      bol(true),
      current(0), next1(0), next2(0), next3(0),
      err(NoError),
      check_reserved(true),
      parenthesesState(IgnoreParentheses),
      prohibitAutomaticSemicolon(false)
{
    // allocate space for read buffers
    buffer8 = new char[size8];
    buffer16 = new QChar[size16];
    flags = 0;

}

QScript::Lexer::~Lexer()
{
    delete [] buffer8;
    delete [] buffer16;
}

void QScript::Lexer::setCode(const QString &c, int lineno)
{
    errmsg = QString();
    yylineno = lineno;
    yycolumn = 1;
    restrKeyword = false;
    delimited = false;
    stackToken = -1;
    pos = 0;
    code = c.unicode();
    length = c.length();
    bol = true;

    // read first characters
    current = (length > 0) ? code[0].unicode() : 0;
    next1 = (length > 1) ? code[1].unicode() : 0;
    next2 = (length > 2) ? code[2].unicode() : 0;
    next3 = (length > 3) ? code[3].unicode() : 0;
}

void QScript::Lexer::shift(uint p)
{
    while (p--) {
        ++pos;
        ++yycolumn;
        current = next1;
        next1 = next2;
        next2 = next3;
        next3 = (pos + 3 < length) ? code[pos+3].unicode() : 0;
    }
}

void QScript::Lexer::setDone(State s)
{
    state = s;
    done = true;
}

int QScript::Lexer::findReservedWord(const QChar *c, int size) const
{
    switch (size) {
    case 2: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o'))
            return QScriptGrammar::T_DO;
        else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('f'))
            return QScriptGrammar::T_IF;
        else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n'))
            return QScriptGrammar::T_IN;
    }   break;

    case 3: {
        if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('o') && c[2] == QLatin1Char('r'))
            return QScriptGrammar::T_FOR;
        else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('e') && c[2] == QLatin1Char('w'))
            return QScriptGrammar::T_NEW;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r') && c[2] == QLatin1Char('y'))
            return QScriptGrammar::T_TRY;
        else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('a') && c[2] == QLatin1Char('r'))
            return QScriptGrammar::T_VAR;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n') && c[2] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 4: {
        if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_CASE;
        else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('l')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_ELSE;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('s'))
            return QScriptGrammar::T_THIS;
        else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('d'))
            return QScriptGrammar::T_VOID;
        else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('i')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('h'))
            return QScriptGrammar::T_WITH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_TRUE;
        else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('u')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('l'))
            return QScriptGrammar::T_NULL;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('n')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('m'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('l') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('g'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('r'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('g') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('o'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 5: {
        if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('r')
                && c[2] == QLatin1Char('e') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('k'))
            return QScriptGrammar::T_BREAK;
        else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('c')
                && c[4] == QLatin1Char('h'))
            return QScriptGrammar::T_CATCH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                && c[4] == QLatin1Char('w'))
            return QScriptGrammar::T_THROW;
        else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('l')
                && c[4] == QLatin1Char('e'))
            return QScriptGrammar::T_WHILE;
        else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('s')
                && c[4] == QLatin1Char('t'))
            return QScriptGrammar::T_CONST;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('s')
                && c[4] == QLatin1Char('e'))
            return QScriptGrammar::T_FALSE;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('r')
                    && c[4] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('r'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('l'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('s')
                    && c[4] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 6: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('e')
                && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('e'))
            return QScriptGrammar::T_DELETE;
        else if (c[0] == QLatin1Char('r') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('u')
                && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('n'))
            return QScriptGrammar::T_RETURN;
        else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('w')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('c') && c[5] == QLatin1Char('h'))
            return QScriptGrammar::T_SWITCH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('y')
                && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                && c[4] == QLatin1Char('o') && c[5] == QLatin1Char('f'))
            return QScriptGrammar::T_TYPEOF;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('t')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('b')
                    && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('i')
                    && c[4] == QLatin1Char('v') && c[5] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('w') && c[5] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 7: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('f') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('u') && c[5] == QLatin1Char('l')
                && c[6] == QLatin1Char('t'))
            return QScriptGrammar::T_DEFAULT;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('l')
                && c[6] == QLatin1Char('y'))
            return QScriptGrammar::T_FINALLY;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('a')
                    && c[6] == QLatin1Char('n'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('n') && c[5] == QLatin1Char('d')
                    && c[6] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('c') && c[3] == QLatin1Char('k')
                    && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('g')
                    && c[6] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('v')
                    && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('t')
                    && c[6] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 8: {
        if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('n')
                && c[6] == QLatin1Char('u') && c[7] == QLatin1Char('e'))
            return QScriptGrammar::T_CONTINUE;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('u')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n'))
            return QScriptGrammar::T_FUNCTION;
        else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('u')
                && c[4] == QLatin1Char('g') && c[5] == QLatin1Char('g')
                && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('r'))
            return QScriptGrammar::T_DEBUGGER;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('a') && c[1] == QLatin1Char('b')
                    && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('a')
                    && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('l') && c[7] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 9: {
        if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('f')
                    && c[6] == QLatin1Char('a') && c[7] == QLatin1Char('c')
                    && c[8] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('n')
                    && c[4] == QLatin1Char('s') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('c')
                    && c[6] == QLatin1Char('t') && c[7] == QLatin1Char('e')
                    && c[8] == QLatin1Char('d'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 10: {
        if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('n')
                && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('e')
                && c[8] == QLatin1Char('o') && c[9] == QLatin1Char('f'))
            return QScriptGrammar::T_INSTANCEOF;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('m')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('t') && c[9] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 12: {
        if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                    && c[4] == QLatin1Char('h') && c[5] == QLatin1Char('r')
                    && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('i') && c[9] == QLatin1Char('z')
                    && c[10] == QLatin1Char('e') && c[11] == QLatin1Char('d'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    } // switch

    return -1;
}

int QScript::Lexer::lex()
{
    int token = 0;
    state = Start;
    ushort stringType = 0; // either single or double quotes
    pos8 = pos16 = 0;
    done = false;
    terminator = false;

    // did we push a token on the stack previously ?
    // (after an automatic semicolon insertion)
    if (stackToken >= 0) {
        setDone(Other);
        token = stackToken;
        stackToken = -1;
    }

    while (!done) {
        switch (state) {
        case Start:
            if (isWhiteSpace()) {
                // do nothing
            } else if (current == '/' && next1 == '/') {
                recordStartPos();
                shift(1);
                state = InSingleLineComment;
            } else if (current == '/' && next1 == '*') {
                recordStartPos();
                shift(1);
                state = InMultiLineComment;
            } else if (current == 0) {
                syncProhibitAutomaticSemicolon();
                if (!terminator && !delimited && !prohibitAutomaticSemicolon) {
                    // automatic semicolon insertion if program incomplete
                    token = QScriptGrammar::T_SEMICOLON;
                    stackToken = 0;
                    setDone(Other);
                } else {
                    setDone(Eof);
                }
            } else if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
                yycolumn = 0;
                bol = true;
                terminator = true;
                syncProhibitAutomaticSemicolon();
                if (restrKeyword) {
                    token = QScriptGrammar::T_SEMICOLON;
                    setDone(Other);
                }
            } else if (current == '"' || current == '\'') {
                recordStartPos();
                state = InString;
                stringType = current;
            } else if (isIdentLetter(current)) {
                recordStartPos();
                record16(current);
                state = InIdentifier;
            } else if (current == '0') {
                recordStartPos();
                record8(current);
                state = InNum0;
            } else if (isDecimalDigit(current)) {
                recordStartPos();
                record8(current);
                state = InNum;
            } else if (current == '.' && isDecimalDigit(next1)) {
                recordStartPos();
                record8(current);
                state = InDecimal;
            } else {
                recordStartPos();
                token = matchPunctuator(current, next1, next2, next3);
                if (token != -1) {
                    if (terminator && !delimited && !prohibitAutomaticSemicolon
                        && (token == QScriptGrammar::T_PLUS_PLUS
                            || token == QScriptGrammar::T_MINUS_MINUS)) {
                        // automatic semicolon insertion
                        stackToken = token;
                        token = QScriptGrammar::T_SEMICOLON;
                    }
                    setDone(Other);
                }
                else {
                    setDone(Bad);
                    err = IllegalCharacter;
                    errmsg = QLatin1String("Illegal character");
                }
            }
            break;
        case InString:
            if (current == stringType) {
                shift(1);
                setDone(String);
            } else if (current == 0 || isLineTerminator()) {
                setDone(Bad);
                err = UnclosedStringLiteral;
                errmsg = QLatin1String("Unclosed string at end of line");
            } else if (current == '\\') {
                state = InEscapeSequence;
            } else {
                record16(current);
            }
            break;
            // Escape Sequences inside of strings
        case InEscapeSequence:
            if (isOctalDigit(current)) {
                if (current >= '0' && current <= '3' &&
                     isOctalDigit(next1) && isOctalDigit(next2)) {
                    record16(convertOctal(current, next1, next2));
                    shift(2);
                    state = InString;
                } else if (isOctalDigit(current) &&
                            isOctalDigit(next1)) {
                    record16(convertOctal('0', current, next1));
                    shift(1);
                    state = InString;
                } else if (isOctalDigit(current)) {
                    record16(convertOctal('0', '0', current));
                    state = InString;
                } else {
                    setDone(Bad);
                    err = IllegalEscapeSequence;
                    errmsg = QLatin1String("Illegal escape squence");
                }
            } else if (current == 'x')
                state = InHexEscape;
            else if (current == 'u')
                state = InUnicodeEscape;
            else {
                record16(singleEscape(current));
                state = InString;
            }
            break;
        case InHexEscape:
            if (isHexDigit(current) && isHexDigit(next1)) {
                state = InString;
                record16(QLatin1Char(convertHex(current, next1)));
                shift(1);
            } else if (current == stringType) {
                record16(QLatin1Char('x'));
                shift(1);
                setDone(String);
            } else {
                record16(QLatin1Char('x'));
                record16(current);
                state = InString;
            }
            break;
        case InUnicodeEscape:
            if (isHexDigit(current) && isHexDigit(next1) &&
                 isHexDigit(next2) && isHexDigit(next3)) {
                record16(convertUnicode(current, next1, next2, next3));
                shift(3);
                state = InString;
            } else if (current == stringType) {
                record16(QLatin1Char('u'));
                shift(1);
                setDone(String);
            } else {
                setDone(Bad);
                err = IllegalUnicodeEscapeSequence;
                errmsg = QLatin1String("Illegal unicode escape sequence");
            }
            break;
        case InSingleLineComment:
            if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
                yycolumn = 0;
                terminator = true;
                bol = true;
                if (restrKeyword) {
                    token = QScriptGrammar::T_SEMICOLON;
                    setDone(Other);
                } else
                    state = Start;
            } else if (current == 0) {
                setDone(Eof);
            }
            break;
        case InMultiLineComment:
            if (current == 0) {
                setDone(Bad);
                err = UnclosedComment;
                errmsg = QLatin1String("Unclosed comment at end of file");
            } else if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
            } else if (current == '*' && next1 == '/') {
                state = Start;
                shift(1);
            }
            break;
        case InIdentifier:
            if (isIdentLetter(current) || isDecimalDigit(current)) {
                record16(current);
                break;
            }
            setDone(Identifier);
            break;
        case InNum0:
            if (current == 'x' || current == 'X') {
                record8(current);
                state = InHex;
            } else if (current == '.') {
                record8(current);
                state = InDecimal;
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else if (isOctalDigit(current)) {
                record8(current);
                state = InOctal;
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InDecimal;
            } else {
                setDone(Number);
            }
            break;
        case InHex:
            if (isHexDigit(current))
                record8(current);
            else
                setDone(Hex);
            break;
        case InOctal:
            if (isOctalDigit(current)) {
                record8(current);
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InDecimal;
            } else {
                setDone(Octal);
            }
            break;
        case InNum:
            if (isDecimalDigit(current)) {
                record8(current);
            } else if (current == '.') {
                record8(current);
                state = InDecimal;
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else {
                setDone(Number);
            }
            break;
        case InDecimal:
            if (isDecimalDigit(current)) {
                record8(current);
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else {
                setDone(Number);
            }
            break;
        case InExponentIndicator:
            if (current == '+' || current == '-') {
                record8(current);
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InExponent;
            } else {
                setDone(Bad);
                err = IllegalExponentIndicator;
                errmsg = QLatin1String("Illegal syntax for exponential number");
            }
            break;
        case InExponent:
            if (isDecimalDigit(current)) {
                record8(current);
            } else {
                setDone(Number);
            }
            break;
        default:
            Q_ASSERT_X(0, "Lexer::lex", "Unhandled state in switch statement");
        }

        // move on to the next character
        if (!done)
            shift(1);
        if (state != Start && state != InSingleLineComment)
            bol = false;
    }

    // no identifiers allowed directly after numeric literal, e.g. "3in" is bad
    if ((state == Number || state == Octal || state == Hex)
         && isIdentLetter(current)) {
        state = Bad;
        err = IllegalIdentifier;
        errmsg = QLatin1String("Identifier cannot start with numeric literal");
    }

    // terminate string
    buffer8[pos8] = '\0';

    double dval = 0;
    if (state == Number) {
        dval = qstrtod(buffer8, 0, 0);
    } else if (state == Hex) { // scan hex numbers
        dval = QScript::integerFromString(buffer8, pos8, 16);
        state = Number;
    } else if (state == Octal) {   // scan octal number
        dval = QScript::integerFromString(buffer8, pos8, 8);
        state = Number;
    }

    restrKeyword = false;
    delimited = false;

    switch (parenthesesState) {
    case IgnoreParentheses:
        break;
    case CountParentheses:
        if (token == QScriptGrammar::T_RPAREN) {
            --parenthesesCount;
            if (parenthesesCount == 0)
                parenthesesState = BalancedParentheses;
        } else if (token == QScriptGrammar::T_LPAREN) {
            ++parenthesesCount;
        }
        break;
    case BalancedParentheses:
        parenthesesState = IgnoreParentheses;
        break;
    }

    switch (state) {
    case Eof:
        return 0;
    case Other:
        if(token == QScriptGrammar::T_RBRACE || token == QScriptGrammar::T_SEMICOLON)
            delimited = true;
        return token;
    case Identifier:
        if ((token = findReservedWord(buffer16, pos16)) < 0) {
            /* TODO: close leak on parse error. same holds true for String */
            qsyylval = QString(buffer16, pos16);
            return QScriptGrammar::T_IDENTIFIER;
        }
        if (token == QScriptGrammar::T_CONTINUE || token == QScriptGrammar::T_BREAK
            || token == QScriptGrammar::T_RETURN || token == QScriptGrammar::T_THROW) {
            restrKeyword = true;
        } else if (token == QScriptGrammar::T_IF || token == QScriptGrammar::T_FOR
                   || token == QScriptGrammar::T_WHILE || token == QScriptGrammar::T_WITH) {
            parenthesesState = CountParentheses;
            parenthesesCount = 0;
        } else if (token == QScriptGrammar::T_DO) {
            parenthesesState = BalancedParentheses;
        }
        return token;
    case String:
        qsyylval = QString(buffer16, pos16);
        return QScriptGrammar::T_STRING_LITERAL;
    case Number:
        qsyylval = dval;
        return QScriptGrammar::T_NUMERIC_LITERAL;
    case Bad:
        return -1;
    default:
        Q_ASSERT(!"unhandled numeration value in switch");
        return -1;
    }
}

bool QScript::Lexer::isWhiteSpace() const
{
    return (current == ' ' || current == '\t' ||
             current == 0x0b || current == 0x0c);
}

bool QScript::Lexer::isLineTerminator() const
{
    return (current == '\n' || current == '\r');
}

bool QScript::Lexer::isIdentLetter(ushort c)
{
    /* TODO: allow other legitimate unicode chars */
    return ((c >= 'a' && c <= 'z')
            || (c >= 'A' && c <= 'Z')
            || c == '$'
            || c == '_');
}

bool QScript::Lexer::isDecimalDigit(ushort c)
{
    return (c >= '0' && c <= '9');
}

bool QScript::Lexer::isHexDigit(ushort c) const
{
    return ((c >= '0' && c <= '9')
            || (c >= 'a' && c <= 'f')
            || (c >= 'A' && c <= 'F'));
}

bool QScript::Lexer::isOctalDigit(ushort c) const
{
    return (c >= '0' && c <= '7');
}

int QScript::Lexer::matchPunctuator(ushort c1, ushort c2,
                            ushort c3, ushort c4)
{
    if (c1 == '>' && c2 == '>' && c3 == '>' && c4 == '=') {
        shift(4);
        return QScriptGrammar::T_GT_GT_GT_EQ;
    } else if (c1 == '=' && c2 == '=' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_EQ_EQ_EQ;
    } else if (c1 == '!' && c2 == '=' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_NOT_EQ_EQ;
    } else if (c1 == '>' && c2 == '>' && c3 == '>') {
        shift(3);
        return QScriptGrammar::T_GT_GT_GT;
    } else if (c1 == '<' && c2 == '<' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_LT_LT_EQ;
    } else if (c1 == '>' && c2 == '>' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_GT_GT_EQ;
    } else if (c1 == '<' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_LE;
    } else if (c1 == '>' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_GE;
    } else if (c1 == '!' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_NOT_EQ;
    } else if (c1 == '+' && c2 == '+') {
        shift(2);
        return QScriptGrammar::T_PLUS_PLUS;
    } else if (c1 == '-' && c2 == '-') {
        shift(2);
        return QScriptGrammar::T_MINUS_MINUS;
    } else if (c1 == '=' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_EQ_EQ;
    } else if (c1 == '+' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_PLUS_EQ;
    } else if (c1 == '-' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_MINUS_EQ;
    } else if (c1 == '*' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_STAR_EQ;
    } else if (c1 == '/' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_DIVIDE_EQ;
    } else if (c1 == '&' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_AND_EQ;
    } else if (c1 == '^' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_XOR_EQ;
    } else if (c1 == '%' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_REMAINDER_EQ;
    } else if (c1 == '|' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_OR_EQ;
    } else if (c1 == '<' && c2 == '<') {
        shift(2);
        return QScriptGrammar::T_LT_LT;
    } else if (c1 == '>' && c2 == '>') {
        shift(2);
        return QScriptGrammar::T_GT_GT;
    } else if (c1 == '&' && c2 == '&') {
        shift(2);
        return QScriptGrammar::T_AND_AND;
    } else if (c1 == '|' && c2 == '|') {
        shift(2);
        return QScriptGrammar::T_OR_OR;
    }

    switch(c1) {
        case '=': shift(1); return QScriptGrammar::T_EQ;
        case '>': shift(1); return QScriptGrammar::T_GT;
        case '<': shift(1); return QScriptGrammar::T_LT;
        case ',': shift(1); return QScriptGrammar::T_COMMA;
        case '!': shift(1); return QScriptGrammar::T_NOT;
        case '~': shift(1); return QScriptGrammar::T_TILDE;
        case '?': shift(1); return QScriptGrammar::T_QUESTION;
        case ':': shift(1); return QScriptGrammar::T_COLON;
        case '.': shift(1); return QScriptGrammar::T_DOT;
        case '+': shift(1); return QScriptGrammar::T_PLUS;
        case '-': shift(1); return QScriptGrammar::T_MINUS;
        case '*': shift(1); return QScriptGrammar::T_STAR;
        case '/': shift(1); return QScriptGrammar::T_DIVIDE_;
        case '&': shift(1); return QScriptGrammar::T_AND;
        case '|': shift(1); return QScriptGrammar::T_OR;
        case '^': shift(1); return QScriptGrammar::T_XOR;
        case '%': shift(1); return QScriptGrammar::T_REMAINDER;
        case '(': shift(1); return QScriptGrammar::T_LPAREN;
        case ')': shift(1); return QScriptGrammar::T_RPAREN;
        case '{': shift(1); return QScriptGrammar::T_LBRACE;
        case '}': shift(1); return QScriptGrammar::T_RBRACE;
        case '[': shift(1); return QScriptGrammar::T_LBRACKET;
        case ']': shift(1); return QScriptGrammar::T_RBRACKET;
        case ';': shift(1); return QScriptGrammar::T_SEMICOLON;

        default: return -1;
    }
}

ushort QScript::Lexer::singleEscape(ushort c) const
{
    switch(c) {
    case 'b':
        return 0x08;
    case 't':
        return 0x09;
    case 'n':
        return 0x0A;
    case 'v':
        return 0x0B;
    case 'f':
        return 0x0C;
    case 'r':
        return 0x0D;
    case '"':
        return 0x22;
    case '\'':
        return 0x27;
    case '\\':
        return 0x5C;
    default:
        return c;
    }
}

ushort QScript::Lexer::convertOctal(ushort c1, ushort c2,
                            ushort c3) const
{
    return ((c1 - '0') * 64 + (c2 - '0') * 8 + c3 - '0');
}

unsigned char QScript::Lexer::convertHex(ushort c)
{
    if (c >= '0' && c <= '9')
        return (c - '0');
    else if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);
    else
        return (c - 'A' + 10);
}

unsigned char QScript::Lexer::convertHex(ushort c1, ushort c2)
{
    return ((convertHex(c1) << 4) + convertHex(c2));
}

QChar QScript::Lexer::convertUnicode(ushort c1, ushort c2,
                             ushort c3, ushort c4)
{
    return QChar((convertHex(c3) << 4) + convertHex(c4),
                  (convertHex(c1) << 4) + convertHex(c2));
}

void QScript::Lexer::record8(ushort c)
{
    Q_ASSERT(c <= 0xff);

    // enlarge buffer if full
    if (pos8 >= size8 - 1) {
        char *tmp = new char[2 * size8];
        memcpy(tmp, buffer8, size8 * sizeof(char));
        delete [] buffer8;
        buffer8 = tmp;
        size8 *= 2;
    }

    buffer8[pos8++] = (char) c;
}

void QScript::Lexer::record16(QChar c)
{
    // enlarge buffer if full
    if (pos16 >= size16 - 1) {
        QChar *tmp = new QChar[2 * size16];
        memcpy(tmp, buffer16, size16 * sizeof(QChar));
        delete [] buffer16;
        buffer16 = tmp;
        size16 *= 2;
    }

    buffer16[pos16++] = c;
}

void QScript::Lexer::recordStartPos()
{
    startlineno = yylineno;
    startcolumn = yycolumn;
}

bool QScript::Lexer::scanRegExp(RegExpBodyPrefix prefix)
{
    pos16 = 0;
    bool lastWasEscape = false;

    if (prefix == EqualPrefix)
        record16(QLatin1Char('='));

    while (1) {
        if (isLineTerminator() || current == 0) {
            errmsg = QLatin1String("Unterminated regular expression literal");
            return false;
        }
        else if (current != '/' || lastWasEscape == true)
            {
                record16(current);
                lastWasEscape = !lastWasEscape && (current == '\\');
            }
        else {
            pattern = QString(buffer16, pos16);
            pos16 = 0;
            shift(1);
            break;
        }
        shift(1);
    }

    flags = 0;
    while (isIdentLetter(current)) {
        record16(current);
        shift(1);
    }

    return true;
}

void QScript::Lexer::syncProhibitAutomaticSemicolon()
{
    if (parenthesesState == BalancedParentheses) {
        // we have seen something like "if (foo)", which means we should
        // never insert an automatic semicolon at this point, since it would
        // then be expanded into an empty statement (ECMA-262 7.9.1)
        prohibitAutomaticSemicolon = true;
        parenthesesState = IgnoreParentheses;
    } else {
        prohibitAutomaticSemicolon = false;
    }
}


class Translator;

class QScriptParser: protected QScriptGrammar
{
public:
    QVariant val;

    struct Location {
      int startLine;
      int startColumn;
      int endLine;
      int endColumn;
    };

public:
    QScriptParser();
    ~QScriptParser();

    bool parse(QScript::Lexer *lexer,
               const QString &fileName,
               Translator *translator);

    inline QString errorMessage() const
    { return error_message; }
    inline int errorLineNumber() const
    { return error_lineno; }
    inline int errorColumnNumber() const
    { return error_column; }

protected:
    inline void reallocateStack();

    inline QVariant &sym(int index)
    { return sym_stack [tos + index - 1]; }

    inline Location &loc(int index)
    { return location_stack [tos + index - 2]; }

protected:
    int tos;
    int stack_size;
    QVector<QVariant> sym_stack;
    int *state_stack;
    Location *location_stack;
    QString error_message;
    int error_lineno;
    int error_column;
};

inline void QScriptParser::reallocateStack()
{
    if (! stack_size)
        stack_size = 128;
    else
        stack_size <<= 1;

    sym_stack.resize(stack_size);
    state_stack = reinterpret_cast<int*> (qRealloc(state_stack, stack_size * sizeof(int)));
    location_stack = reinterpret_cast<Location*> (qRealloc(location_stack, stack_size * sizeof(Location)));
}

inline static bool automatic(QScript::Lexer *lexer, int token)
{
    return (token == QScriptGrammar::T_RBRACE)
        || (token == 0)
        || lexer->prevTerminator();
}

QScriptParser::QScriptParser():
    tos(0),
    stack_size(0),
    sym_stack(0),
    state_stack(0),
    location_stack(0)
{
}

QScriptParser::~QScriptParser()
{
    if (stack_size) {
        qFree(state_stack);
        qFree(location_stack);
    }
}

static inline QScriptParser::Location location(QScript::Lexer *lexer)
{
    QScriptParser::Location loc;
    loc.startLine = lexer->startLineNo();
    loc.startColumn = lexer->startColumnNo();
    loc.endLine = lexer->endLineNo();
    loc.endColumn = lexer->endColumnNo();
    return loc;
}

bool QScriptParser::parse(QScript::Lexer *lexer,
                    const QString &fileName,
     	            Translator *translator)
{
  const int INITIAL_STATE = 0;

  int yytoken = -1;
  int saved_yytoken = -1;
  int identLineNo = -1;

  reallocateStack();

  tos = 0;
  state_stack[++tos] = INITIAL_STATE;

  while (true)
    {
      const int state = state_stack [tos];
      if (yytoken == -1 && - TERMINAL_COUNT != action_index [state])
        {
          if (saved_yytoken == -1)
            {
              yytoken = lexer->lex();
              location_stack [tos] = location(lexer);
            }
          else
            {
              yytoken = saved_yytoken;
              saved_yytoken = -1;
            }
        }

      int act = t_action (state, yytoken);

      if (act == ACCEPT_STATE)
        return true;

      else if (act > 0)
        {
          if (++tos == stack_size)
            reallocateStack();

          sym_stack [tos] = lexer->val ();
          state_stack [tos] = act;
          location_stack [tos] = location(lexer);
          yytoken = -1;
        }

      else if (act < 0)
        {
          int r = - act - 1;

          tos -= rhs [r];
          act = state_stack [tos++];

          switch (r) {

case 1: {
    sym(1) = sym(1).toByteArray();
    identLineNo = lexer->startLineNo();
} break;

case 7: {
  bool rx = lexer->scanRegExp(QScript::Lexer::NoPrefix);
  if (!rx) {
      error_message = lexer->errorMessage();
      error_lineno = lexer->startLineNo();
      error_column = lexer->startColumnNo();
      return false;
  }
} break;

case 8: {
  bool rx = lexer->scanRegExp(QScript::Lexer::EqualPrefix);
  if (!rx) {
      error_message = lexer->errorMessage();
      error_lineno = lexer->startLineNo();
      error_column = lexer->startColumnNo();
      return false;
  }
} break;

case 66: {
    QString name = sym(1).toString();
    if ((name == QLatin1String("qsTranslate")) || (name == QLatin1String("QT_TRANSLATE_NOOP"))) {
        QVariantList args = sym(2).toList();
        if (args.size() < 2) {
            qWarning("%s:%d: %s() requires at least two arguments",
                     qPrintable(fileName), identLineNo, qPrintable(name));
        } else {
            if ((args.at(0).type() != QVariant::String)
                || (args.at(1).type() != QVariant::String)) {
                qWarning("%s:%d: %s(): both arguments must be literal strings",
                         qPrintable(fileName), identLineNo, qPrintable(name));
            } else {
                QString context = args.at(0).toString();
                QString text = args.at(1).toString();
                QString comment = args.value(2).toString();
                QString extracomment;
                bool plural = (args.size() > 4);
                recordMessage(translator, context, text, comment, extracomment,
                              plural, fileName, identLineNo);
            }
        }
    } else if ((name == QLatin1String("qsTr")) || (name == QLatin1String("QT_TR_NOOP"))) {
        QVariantList args = sym(2).toList();
        if (args.size() < 1) {
            qWarning("%s:%d: %s() requires at least one argument",
                     qPrintable(fileName), identLineNo, qPrintable(name));
        } else {
            if (args.at(0).type() != QVariant::String) {
                qWarning("%s:%d: %s(): text to translate must be a literal string",
                         qPrintable(fileName), identLineNo, qPrintable(name));
            } else {
                QString context = QFileInfo(fileName).baseName();
                QString text = args.at(0).toString();
                QString comment = args.value(1).toString();
                QString extracomment;
                bool plural = (args.size() > 2);
                recordMessage(translator, context, text, comment, extracomment,
                              plural, fileName, identLineNo);
            }
        }
    }
} break;

case 70: {
    sym(1) = QVariantList();
} break;

case 71: {
    sym(1) = sym(2);
} break;

case 72: {
    sym(1) = QVariantList() << sym(1);
} break;

case 73: {
    sym(1) = sym(1).toList() << sym(3);
} break;

case 94: {
    if ((sym(1).type() == QVariant::String) || (sym(3).type() == QVariant::String))
        sym(1) = sym(1).toString() + sym(3).toString();
    else
        sym(1) = QVariant();
} break;

          } // switch

          state_stack [tos] = nt_action (act, lhs [r] - TERMINAL_COUNT);

          if (rhs[r] > 1) {
              location_stack[tos - 1].endLine = location_stack[tos + rhs[r] - 2].endLine;
              location_stack[tos - 1].endColumn = location_stack[tos + rhs[r] - 2].endColumn;
              location_stack[tos] = location_stack[tos + rhs[r] - 1];
          }
        }

      else
        {
          if (saved_yytoken == -1 && automatic (lexer, yytoken) && t_action (state, T_AUTOMATIC_SEMICOLON) > 0)
            {
              saved_yytoken = yytoken;
              yytoken = T_SEMICOLON;
              continue;
            }

          else if ((state == INITIAL_STATE) && (yytoken == 0)) {
              // accept empty input
              yytoken = T_SEMICOLON;
              continue;
          }

          int ers = state;
          int shifts = 0;
          int reduces = 0;
          int expected_tokens [3];
          for (int tk = 0; tk < TERMINAL_COUNT; ++tk)
            {
              int k = t_action (ers, tk);

              if (! k)
                continue;
              else if (k < 0)
                ++reduces;
              else if (spell [tk])
                {
                  if (shifts < 3)
                    expected_tokens [shifts] = tk;
                  ++shifts;
                }
            }

          error_message.clear ();
          if (shifts && shifts < 3)
            {
              bool first = true;

              for (int s = 0; s < shifts; ++s)
                {
                  if (first)
                    error_message += QLatin1String ("Expected ");
                  else
                    error_message += QLatin1String (", ");

                  first = false;
                  error_message += QLatin1String("`");
                  error_message += QLatin1String (spell [expected_tokens [s]]);
                  error_message += QLatin1String("'");
                }
            }

          if (error_message.isEmpty())
              error_message = lexer->errorMessage();

          error_lineno = lexer->startLineNo();
          error_column = lexer->startColumnNo();

          return false;
        }
    }

    return false;
}


bool loadQScript(Translator &translator, QIODevice &dev, ConversionData &cd)
{
    QTextStream ts(&dev);
    QByteArray codecName;
    if (!cd.m_codecForSource.isEmpty())
        codecName = cd.m_codecForSource;
    else
        codecName = translator.codecName(); // Just because it should be latin1 already
    ts.setCodec(QTextCodec::codecForName(codecName));
    ts.setAutoDetectUnicode(true);

    QString code = ts.readAll();
    QScript::Lexer lexer;
    lexer.setCode(code, /*lineNumber=*/1);
    QScriptParser parser;
    if (!parser.parse(&lexer, cd.m_sourceFileName, &translator)) {
        qWarning("%s:%d: %s", qPrintable(cd.m_sourceFileName), parser.errorLineNumber(),
                 qPrintable(parser.errorMessage()));
        return false;
    }

    // Java uses UTF-16 internally and Jambi makes UTF-8 for tr() purposes of it.
    translator.setCodecName("UTF-8");
    return true;
}

bool saveQScript(const Translator &translator, QIODevice &dev, ConversionData &cd) 
{
    Q_UNUSED(dev);
    Q_UNUSED(translator);
    cd.appendError(QLatin1String("Cannot save .js files"));
    return false;
}

int initQScript()
{
    Translator::FileFormat format;
    format.extension = QLatin1String("js");
    format.fileType = Translator::FileFormat::SourceCode;
    format.priority = 0;
    format.description = QObject::tr("Qt Script source files");
    format.loader = &loadQScript;
    format.saver = &saveQScript;
    Translator::registerFileFormat(format);
    return 1;
}

Q_CONSTRUCTOR_FUNCTION(initQScript)

QT_END_NAMESPACE
